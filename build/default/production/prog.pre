
# 1 "prog.c"

# 26 "/opt/microchip/xc8/v1.37/include/htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "/opt/microchip/xc8/v1.37/include/xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 49 "/opt/microchip/xc8/v1.37/include/pic18f2620.h"
extern volatile unsigned char PORTA @ 0xF80;

asm("PORTA equ 0F80h");


typedef union {
struct {
unsigned RA0 :1;
unsigned RA1 :1;
unsigned RA2 :1;
unsigned RA3 :1;
unsigned RA4 :1;
unsigned RA5 :1;
unsigned RA6 :1;
unsigned RA7 :1;
};
struct {
unsigned :4;
unsigned T0CKI :1;
unsigned AN4 :1;
};
struct {
unsigned :5;
unsigned SS :1;
};
struct {
unsigned :5;
unsigned NOT_SS :1;
};
struct {
unsigned :5;
unsigned nSS :1;
};
struct {
unsigned :5;
unsigned LVDIN :1;
};
struct {
unsigned :5;
unsigned HLVDIN :1;
};
struct {
unsigned :7;
unsigned RJPU :1;
};
struct {
unsigned ULPWUIN :1;
};
} PORTAbits_t;
extern volatile PORTAbits_t PORTAbits @ 0xF80;

# 187
extern volatile unsigned char PORTB @ 0xF81;

asm("PORTB equ 0F81h");


typedef union {
struct {
unsigned RB0 :1;
unsigned RB1 :1;
unsigned RB2 :1;
unsigned RB3 :1;
unsigned RB4 :1;
unsigned RB5 :1;
unsigned RB6 :1;
unsigned RB7 :1;
};
struct {
unsigned INT0 :1;
unsigned INT1 :1;
unsigned INT2 :1;
unsigned CCP2 :1;
unsigned KBI0 :1;
unsigned KBI1 :1;
unsigned KBI2 :1;
unsigned KBI3 :1;
};
struct {
unsigned AN12 :1;
unsigned AN10 :1;
unsigned AN8 :1;
unsigned AN9 :1;
unsigned AN11 :1;
unsigned PGM :1;
unsigned PGC :1;
unsigned PGD :1;
};
struct {
unsigned :3;
unsigned CCP2_PA2 :1;
};
} PORTBbits_t;
extern volatile PORTBbits_t PORTBbits @ 0xF81;

# 357
extern volatile unsigned char PORTC @ 0xF82;

asm("PORTC equ 0F82h");


typedef union {
struct {
unsigned RC0 :1;
unsigned RC1 :1;
unsigned RC2 :1;
unsigned RC3 :1;
unsigned RC4 :1;
unsigned RC5 :1;
unsigned RC6 :1;
unsigned RC7 :1;
};
struct {
unsigned T1OSO :1;
unsigned T1OSI :1;
unsigned CCP1 :1;
unsigned SCK :1;
unsigned SDI :1;
unsigned SDO :1;
unsigned TX :1;
unsigned RX :1;
};
struct {
unsigned T13CKI :1;
unsigned CCP2 :1;
unsigned :1;
unsigned SCL :1;
unsigned SDA :1;
unsigned :1;
unsigned CK :1;
unsigned DT :1;
};
struct {
unsigned T1CKI :1;
};
struct {
unsigned :2;
unsigned PA1 :1;
};
struct {
unsigned :1;
unsigned PA2 :1;
};
} PORTCbits_t;
extern volatile PORTCbits_t PORTCbits @ 0xF82;

# 534
extern volatile unsigned char PORTE @ 0xF84;

asm("PORTE equ 0F84h");


typedef union {
struct {
unsigned :3;
unsigned RE3 :1;
};
struct {
unsigned :3;
unsigned MCLR :1;
};
struct {
unsigned :3;
unsigned NOT_MCLR :1;
};
struct {
unsigned :3;
unsigned nMCLR :1;
};
struct {
unsigned :3;
unsigned VPP :1;
};
struct {
unsigned :3;
unsigned CCP9E :1;
};
struct {
unsigned :3;
unsigned PC3E :1;
};
} PORTEbits_t;
extern volatile PORTEbits_t PORTEbits @ 0xF84;

# 608
extern volatile unsigned char LATA @ 0xF89;

asm("LATA equ 0F89h");


typedef union {
struct {
unsigned LATA0 :1;
unsigned LATA1 :1;
unsigned LATA2 :1;
unsigned LATA3 :1;
unsigned LATA4 :1;
unsigned LATA5 :1;
unsigned LATA6 :1;
unsigned LATA7 :1;
};
struct {
unsigned LA0 :1;
};
struct {
unsigned :1;
unsigned LA1 :1;
};
struct {
unsigned :2;
unsigned LA2 :1;
};
struct {
unsigned :3;
unsigned LA3 :1;
};
struct {
unsigned :4;
unsigned LA4 :1;
};
struct {
unsigned :5;
unsigned LA5 :1;
};
struct {
unsigned :6;
unsigned LA6 :1;
};
struct {
unsigned :7;
unsigned LA7 :1;
};
} LATAbits_t;
extern volatile LATAbits_t LATAbits @ 0xF89;

# 740
extern volatile unsigned char LATB @ 0xF8A;

asm("LATB equ 0F8Ah");


typedef union {
struct {
unsigned LATB0 :1;
unsigned LATB1 :1;
unsigned LATB2 :1;
unsigned LATB3 :1;
unsigned LATB4 :1;
unsigned LATB5 :1;
unsigned LATB6 :1;
unsigned LATB7 :1;
};
struct {
unsigned LB0 :1;
};
struct {
unsigned :1;
unsigned LB1 :1;
};
struct {
unsigned :2;
unsigned LB2 :1;
};
struct {
unsigned :3;
unsigned LB3 :1;
};
struct {
unsigned :4;
unsigned LB4 :1;
};
struct {
unsigned :5;
unsigned LB5 :1;
};
struct {
unsigned :6;
unsigned LB6 :1;
};
struct {
unsigned :7;
unsigned LB7 :1;
};
} LATBbits_t;
extern volatile LATBbits_t LATBbits @ 0xF8A;

# 872
extern volatile unsigned char LATC @ 0xF8B;

asm("LATC equ 0F8Bh");


typedef union {
struct {
unsigned LATC0 :1;
unsigned LATC1 :1;
unsigned LATC2 :1;
unsigned LATC3 :1;
unsigned LATC4 :1;
unsigned LATC5 :1;
unsigned LATC6 :1;
unsigned LATC7 :1;
};
struct {
unsigned LC0 :1;
};
struct {
unsigned :1;
unsigned LC1 :1;
};
struct {
unsigned :2;
unsigned LC2 :1;
};
struct {
unsigned :3;
unsigned LC3 :1;
};
struct {
unsigned :4;
unsigned LC4 :1;
};
struct {
unsigned :5;
unsigned LC5 :1;
};
struct {
unsigned :6;
unsigned LC6 :1;
};
struct {
unsigned :7;
unsigned LC7 :1;
};
} LATCbits_t;
extern volatile LATCbits_t LATCbits @ 0xF8B;

# 1004
extern volatile unsigned char TRISA @ 0xF92;

asm("TRISA equ 0F92h");


extern volatile unsigned char DDRA @ 0xF92;

asm("DDRA equ 0F92h");


typedef union {
struct {
unsigned TRISA0 :1;
unsigned TRISA1 :1;
unsigned TRISA2 :1;
unsigned TRISA3 :1;
unsigned TRISA4 :1;
unsigned TRISA5 :1;
unsigned TRISA6 :1;
unsigned TRISA7 :1;
};
struct {
unsigned RA0 :1;
unsigned RA1 :1;
unsigned RA2 :1;
unsigned RA3 :1;
unsigned RA4 :1;
unsigned RA5 :1;
unsigned RA6 :1;
unsigned RA7 :1;
};
} TRISAbits_t;
extern volatile TRISAbits_t TRISAbits @ 0xF92;

# 1119
typedef union {
struct {
unsigned TRISA0 :1;
unsigned TRISA1 :1;
unsigned TRISA2 :1;
unsigned TRISA3 :1;
unsigned TRISA4 :1;
unsigned TRISA5 :1;
unsigned TRISA6 :1;
unsigned TRISA7 :1;
};
struct {
unsigned RA0 :1;
unsigned RA1 :1;
unsigned RA2 :1;
unsigned RA3 :1;
unsigned RA4 :1;
unsigned RA5 :1;
unsigned RA6 :1;
unsigned RA7 :1;
};
} DDRAbits_t;
extern volatile DDRAbits_t DDRAbits @ 0xF92;

# 1225
extern volatile unsigned char TRISB @ 0xF93;

asm("TRISB equ 0F93h");


extern volatile unsigned char DDRB @ 0xF93;

asm("DDRB equ 0F93h");


typedef union {
struct {
unsigned TRISB0 :1;
unsigned TRISB1 :1;
unsigned TRISB2 :1;
unsigned TRISB3 :1;
unsigned TRISB4 :1;
unsigned TRISB5 :1;
unsigned TRISB6 :1;
unsigned TRISB7 :1;
};
struct {
unsigned RB0 :1;
unsigned RB1 :1;
unsigned RB2 :1;
unsigned RB3 :1;
unsigned RB4 :1;
unsigned RB5 :1;
unsigned RB6 :1;
unsigned RB7 :1;
};
} TRISBbits_t;
extern volatile TRISBbits_t TRISBbits @ 0xF93;

# 1340
typedef union {
struct {
unsigned TRISB0 :1;
unsigned TRISB1 :1;
unsigned TRISB2 :1;
unsigned TRISB3 :1;
unsigned TRISB4 :1;
unsigned TRISB5 :1;
unsigned TRISB6 :1;
unsigned TRISB7 :1;
};
struct {
unsigned RB0 :1;
unsigned RB1 :1;
unsigned RB2 :1;
unsigned RB3 :1;
unsigned RB4 :1;
unsigned RB5 :1;
unsigned RB6 :1;
unsigned RB7 :1;
};
} DDRBbits_t;
extern volatile DDRBbits_t DDRBbits @ 0xF93;

# 1446
extern volatile unsigned char TRISC @ 0xF94;

asm("TRISC equ 0F94h");


extern volatile unsigned char DDRC @ 0xF94;

asm("DDRC equ 0F94h");


typedef union {
struct {
unsigned TRISC0 :1;
unsigned TRISC1 :1;
unsigned TRISC2 :1;
unsigned TRISC3 :1;
unsigned TRISC4 :1;
unsigned TRISC5 :1;
unsigned TRISC6 :1;
unsigned TRISC7 :1;
};
struct {
unsigned RC0 :1;
unsigned RC1 :1;
unsigned RC2 :1;
unsigned RC3 :1;
unsigned RC4 :1;
unsigned RC5 :1;
unsigned RC6 :1;
unsigned RC7 :1;
};
} TRISCbits_t;
extern volatile TRISCbits_t TRISCbits @ 0xF94;

# 1561
typedef union {
struct {
unsigned TRISC0 :1;
unsigned TRISC1 :1;
unsigned TRISC2 :1;
unsigned TRISC3 :1;
unsigned TRISC4 :1;
unsigned TRISC5 :1;
unsigned TRISC6 :1;
unsigned TRISC7 :1;
};
struct {
unsigned RC0 :1;
unsigned RC1 :1;
unsigned RC2 :1;
unsigned RC3 :1;
unsigned RC4 :1;
unsigned RC5 :1;
unsigned RC6 :1;
unsigned RC7 :1;
};
} DDRCbits_t;
extern volatile DDRCbits_t DDRCbits @ 0xF94;

# 1667
extern volatile unsigned char OSCTUNE @ 0xF9B;

asm("OSCTUNE equ 0F9Bh");


typedef union {
struct {
unsigned TUN :5;
unsigned :1;
unsigned PLLEN :1;
unsigned INTSRC :1;
};
struct {
unsigned TUN0 :1;
unsigned TUN1 :1;
unsigned TUN2 :1;
unsigned TUN3 :1;
unsigned TUN4 :1;
};
} OSCTUNEbits_t;
extern volatile OSCTUNEbits_t OSCTUNEbits @ 0xF9B;

# 1731
extern volatile unsigned char PIE1 @ 0xF9D;

asm("PIE1 equ 0F9Dh");


typedef union {
struct {
unsigned TMR1IE :1;
unsigned TMR2IE :1;
unsigned CCP1IE :1;
unsigned SSPIE :1;
unsigned TXIE :1;
unsigned RCIE :1;
unsigned ADIE :1;
};
struct {
unsigned :5;
unsigned RC1IE :1;
};
struct {
unsigned :4;
unsigned TX1IE :1;
};
} PIE1bits_t;
extern volatile PIE1bits_t PIE1bits @ 0xF9D;

# 1804
extern volatile unsigned char PIR1 @ 0xF9E;

asm("PIR1 equ 0F9Eh");


typedef union {
struct {
unsigned TMR1IF :1;
unsigned TMR2IF :1;
unsigned CCP1IF :1;
unsigned SSPIF :1;
unsigned TXIF :1;
unsigned RCIF :1;
unsigned ADIF :1;
};
struct {
unsigned :5;
unsigned RC1IF :1;
};
struct {
unsigned :4;
unsigned TX1IF :1;
};
} PIR1bits_t;
extern volatile PIR1bits_t PIR1bits @ 0xF9E;

# 1877
extern volatile unsigned char IPR1 @ 0xF9F;

asm("IPR1 equ 0F9Fh");


typedef union {
struct {
unsigned TMR1IP :1;
unsigned TMR2IP :1;
unsigned CCP1IP :1;
unsigned SSPIP :1;
unsigned TXIP :1;
unsigned RCIP :1;
unsigned ADIP :1;
};
struct {
unsigned :5;
unsigned RC1IP :1;
};
struct {
unsigned :4;
unsigned TX1IP :1;
};
} IPR1bits_t;
extern volatile IPR1bits_t IPR1bits @ 0xF9F;

# 1950
extern volatile unsigned char PIE2 @ 0xFA0;

asm("PIE2 equ 0FA0h");


typedef union {
struct {
unsigned CCP2IE :1;
unsigned TMR3IE :1;
unsigned HLVDIE :1;
unsigned BCLIE :1;
unsigned EEIE :1;
unsigned :1;
unsigned CMIE :1;
unsigned OSCFIE :1;
};
struct {
unsigned :2;
unsigned LVDIE :1;
};
} PIE2bits_t;
extern volatile PIE2bits_t PIE2bits @ 0xFA0;

# 2015
extern volatile unsigned char PIR2 @ 0xFA1;

asm("PIR2 equ 0FA1h");


typedef union {
struct {
unsigned CCP2IF :1;
unsigned TMR3IF :1;
unsigned HLVDIF :1;
unsigned BCLIF :1;
unsigned EEIF :1;
unsigned :1;
unsigned CMIF :1;
unsigned OSCFIF :1;
};
struct {
unsigned :2;
unsigned LVDIF :1;
};
} PIR2bits_t;
extern volatile PIR2bits_t PIR2bits @ 0xFA1;

# 2080
extern volatile unsigned char IPR2 @ 0xFA2;

asm("IPR2 equ 0FA2h");


typedef union {
struct {
unsigned CCP2IP :1;
unsigned TMR3IP :1;
unsigned HLVDIP :1;
unsigned BCLIP :1;
unsigned EEIP :1;
unsigned :1;
unsigned CMIP :1;
unsigned OSCFIP :1;
};
struct {
unsigned :2;
unsigned LVDIP :1;
};
} IPR2bits_t;
extern volatile IPR2bits_t IPR2bits @ 0xFA2;

# 2145
extern volatile unsigned char EECON1 @ 0xFA6;

asm("EECON1 equ 0FA6h");


typedef union {
struct {
unsigned RD :1;
unsigned WR :1;
unsigned WREN :1;
unsigned WRERR :1;
unsigned FREE :1;
unsigned :1;
unsigned CFGS :1;
unsigned EEPGD :1;
};
struct {
unsigned :6;
unsigned EEFS :1;
};
} EECON1bits_t;
extern volatile EECON1bits_t EECON1bits @ 0xFA6;

# 2210
extern volatile unsigned char EECON2 @ 0xFA7;

asm("EECON2 equ 0FA7h");



extern volatile unsigned char EEDATA @ 0xFA8;

asm("EEDATA equ 0FA8h");



extern volatile unsigned char EEADR @ 0xFA9;

asm("EEADR equ 0FA9h");



extern volatile unsigned char EEADRH @ 0xFAA;

asm("EEADRH equ 0FAAh");



extern volatile unsigned char RCSTA @ 0xFAB;

asm("RCSTA equ 0FABh");


extern volatile unsigned char RCSTA1 @ 0xFAB;

asm("RCSTA1 equ 0FABh");


typedef union {
struct {
unsigned RX9D :1;
unsigned OERR :1;
unsigned FERR :1;
unsigned ADDEN :1;
unsigned CREN :1;
unsigned SREN :1;
unsigned RX9 :1;
unsigned SPEN :1;
};
struct {
unsigned :3;
unsigned ADEN :1;
};
struct {
unsigned :5;
unsigned SRENA :1;
};
struct {
unsigned :6;
unsigned RC8_9 :1;
};
struct {
unsigned :6;
unsigned RC9 :1;
};
struct {
unsigned RCD8 :1;
};
} RCSTAbits_t;
extern volatile RCSTAbits_t RCSTAbits @ 0xFAB;

# 2343
typedef union {
struct {
unsigned RX9D :1;
unsigned OERR :1;
unsigned FERR :1;
unsigned ADDEN :1;
unsigned CREN :1;
unsigned SREN :1;
unsigned RX9 :1;
unsigned SPEN :1;
};
struct {
unsigned :3;
unsigned ADEN :1;
};
struct {
unsigned :5;
unsigned SRENA :1;
};
struct {
unsigned :6;
unsigned RC8_9 :1;
};
struct {
unsigned :6;
unsigned RC9 :1;
};
struct {
unsigned RCD8 :1;
};
} RCSTA1bits_t;
extern volatile RCSTA1bits_t RCSTA1bits @ 0xFAB;

# 2443
extern volatile unsigned char TXSTA @ 0xFAC;

asm("TXSTA equ 0FACh");


extern volatile unsigned char TXSTA1 @ 0xFAC;

asm("TXSTA1 equ 0FACh");


typedef union {
struct {
unsigned TX9D :1;
unsigned TRMT :1;
unsigned BRGH :1;
unsigned SENDB :1;
unsigned SYNC :1;
unsigned TXEN :1;
unsigned TX9 :1;
unsigned CSRC :1;
};
struct {
unsigned :2;
unsigned BRGH1 :1;
};
struct {
unsigned :7;
unsigned CSRC1 :1;
};
struct {
unsigned :3;
unsigned SENDB1 :1;
};
struct {
unsigned :4;
unsigned SYNC1 :1;
};
struct {
unsigned :1;
unsigned TRMT1 :1;
};
struct {
unsigned :6;
unsigned TX91 :1;
};
struct {
unsigned TX9D1 :1;
};
struct {
unsigned :5;
unsigned TXEN1 :1;
};
struct {
unsigned :6;
unsigned TX8_9 :1;
};
struct {
unsigned TXD8 :1;
};
} TXSTAbits_t;
extern volatile TXSTAbits_t TXSTAbits @ 0xFAC;

# 2596
typedef union {
struct {
unsigned TX9D :1;
unsigned TRMT :1;
unsigned BRGH :1;
unsigned SENDB :1;
unsigned SYNC :1;
unsigned TXEN :1;
unsigned TX9 :1;
unsigned CSRC :1;
};
struct {
unsigned :2;
unsigned BRGH1 :1;
};
struct {
unsigned :7;
unsigned CSRC1 :1;
};
struct {
unsigned :3;
unsigned SENDB1 :1;
};
struct {
unsigned :4;
unsigned SYNC1 :1;
};
struct {
unsigned :1;
unsigned TRMT1 :1;
};
struct {
unsigned :6;
unsigned TX91 :1;
};
struct {
unsigned TX9D1 :1;
};
struct {
unsigned :5;
unsigned TXEN1 :1;
};
struct {
unsigned :6;
unsigned TX8_9 :1;
};
struct {
unsigned TXD8 :1;
};
} TXSTA1bits_t;
extern volatile TXSTA1bits_t TXSTA1bits @ 0xFAC;

# 2740
extern volatile unsigned char TXREG @ 0xFAD;

asm("TXREG equ 0FADh");


extern volatile unsigned char TXREG1 @ 0xFAD;

asm("TXREG1 equ 0FADh");



extern volatile unsigned char RCREG @ 0xFAE;

asm("RCREG equ 0FAEh");


extern volatile unsigned char RCREG1 @ 0xFAE;

asm("RCREG1 equ 0FAEh");



extern volatile unsigned char SPBRG @ 0xFAF;

asm("SPBRG equ 0FAFh");


extern volatile unsigned char SPBRG1 @ 0xFAF;

asm("SPBRG1 equ 0FAFh");



extern volatile unsigned char SPBRGH @ 0xFB0;

asm("SPBRGH equ 0FB0h");



extern volatile unsigned char T3CON @ 0xFB1;

asm("T3CON equ 0FB1h");


typedef union {
struct {
unsigned :2;
unsigned NOT_T3SYNC :1;
};
struct {
unsigned TMR3ON :1;
unsigned TMR3CS :1;
unsigned nT3SYNC :1;
unsigned T3CCP1 :1;
unsigned T3CKPS :2;
unsigned T3CCP2 :1;
unsigned RD16 :1;
};
struct {
unsigned :2;
unsigned T3SYNC :1;
unsigned :1;
unsigned T3CKPS0 :1;
unsigned T3CKPS1 :1;
};
struct {
unsigned :7;
unsigned RD163 :1;
};
struct {
unsigned :3;
unsigned SOSCEN3 :1;
};
struct {
unsigned :7;
unsigned T3RD16 :1;
};
} T3CONbits_t;
extern volatile T3CONbits_t T3CONbits @ 0xFB1;

# 2892
extern volatile unsigned short TMR3 @ 0xFB2;

asm("TMR3 equ 0FB2h");



extern volatile unsigned char TMR3L @ 0xFB2;

asm("TMR3L equ 0FB2h");



extern volatile unsigned char TMR3H @ 0xFB3;

asm("TMR3H equ 0FB3h");



extern volatile unsigned char CMCON @ 0xFB4;

asm("CMCON equ 0FB4h");


typedef union {
struct {
unsigned CM :3;
unsigned CIS :1;
unsigned C1INV :1;
unsigned C2INV :1;
unsigned C1OUT :1;
unsigned C2OUT :1;
};
struct {
unsigned CM0 :1;
unsigned CM1 :1;
unsigned CM2 :1;
};
struct {
unsigned CMEN0 :1;
};
struct {
unsigned :1;
unsigned CMEN1 :1;
};
struct {
unsigned :2;
unsigned CMEN2 :1;
};
} CMCONbits_t;
extern volatile CMCONbits_t CMCONbits @ 0xFB4;

# 3005
extern volatile unsigned char CVRCON @ 0xFB5;

asm("CVRCON equ 0FB5h");


typedef union {
struct {
unsigned CVR :4;
unsigned CVRSS :1;
unsigned CVRR :1;
unsigned CVROE :1;
unsigned CVREN :1;
};
struct {
unsigned CVR0 :1;
unsigned CVR1 :1;
unsigned CVR2 :1;
unsigned CVR3 :1;
};
struct {
unsigned :6;
unsigned CVROEN :1;
};
} CVRCONbits_t;
extern volatile CVRCONbits_t CVRCONbits @ 0xFB5;

# 3083
extern volatile unsigned char ECCP1AS @ 0xFB6;

asm("ECCP1AS equ 0FB6h");


extern volatile unsigned char ECCPAS @ 0xFB6;

asm("ECCPAS equ 0FB6h");


typedef union {
struct {
unsigned :2;
unsigned PSSAC :2;
unsigned ECCPAS :3;
unsigned ECCPASE :1;
};
struct {
unsigned :2;
unsigned PSSAC0 :1;
unsigned PSSAC1 :1;
unsigned ECCPAS0 :1;
unsigned ECCPAS1 :1;
unsigned ECCPAS2 :1;
};
} ECCP1ASbits_t;
extern volatile ECCP1ASbits_t ECCP1ASbits @ 0xFB6;

# 3152
typedef union {
struct {
unsigned :2;
unsigned PSSAC :2;
unsigned ECCPAS :3;
unsigned ECCPASE :1;
};
struct {
unsigned :2;
unsigned PSSAC0 :1;
unsigned PSSAC1 :1;
unsigned ECCPAS0 :1;
unsigned ECCPAS1 :1;
unsigned ECCPAS2 :1;
};
} ECCPASbits_t;
extern volatile ECCPASbits_t ECCPASbits @ 0xFB6;

# 3212
extern volatile unsigned char PWM1CON @ 0xFB7;

asm("PWM1CON equ 0FB7h");


extern volatile unsigned char ECCP1DEL @ 0xFB7;

asm("ECCP1DEL equ 0FB7h");


typedef union {
struct {
unsigned :7;
unsigned PRSEN :1;
};
} PWM1CONbits_t;
extern volatile PWM1CONbits_t PWM1CONbits @ 0xFB7;

# 3236
typedef union {
struct {
unsigned :7;
unsigned PRSEN :1;
};
} ECCP1DELbits_t;
extern volatile ECCP1DELbits_t ECCP1DELbits @ 0xFB7;

# 3251
extern volatile unsigned char BAUDCON @ 0xFB8;

asm("BAUDCON equ 0FB8h");


extern volatile unsigned char BAUDCTL @ 0xFB8;

asm("BAUDCTL equ 0FB8h");


typedef union {
struct {
unsigned ABDEN :1;
unsigned WUE :1;
unsigned :1;
unsigned BRG16 :1;
unsigned TXCKP :1;
unsigned RXDTP :1;
unsigned RCIDL :1;
unsigned ABDOVF :1;
};
struct {
unsigned :4;
unsigned SCKP :1;
unsigned RXCKP :1;
unsigned RCMT :1;
};
struct {
unsigned :1;
unsigned W4E :1;
};
} BAUDCONbits_t;
extern volatile BAUDCONbits_t BAUDCONbits @ 0xFB8;

# 3341
typedef union {
struct {
unsigned ABDEN :1;
unsigned WUE :1;
unsigned :1;
unsigned BRG16 :1;
unsigned TXCKP :1;
unsigned RXDTP :1;
unsigned RCIDL :1;
unsigned ABDOVF :1;
};
struct {
unsigned :4;
unsigned SCKP :1;
unsigned RXCKP :1;
unsigned RCMT :1;
};
struct {
unsigned :1;
unsigned W4E :1;
};
} BAUDCTLbits_t;
extern volatile BAUDCTLbits_t BAUDCTLbits @ 0xFB8;

# 3422
extern volatile unsigned char CCP2CON @ 0xFBA;

asm("CCP2CON equ 0FBAh");


typedef union {
struct {
unsigned CCP2M :4;
unsigned DC2B :2;
};
struct {
unsigned CCP2M0 :1;
unsigned CCP2M1 :1;
unsigned CCP2M2 :1;
unsigned CCP2M3 :1;
unsigned CCP2Y :1;
unsigned CCP2X :1;
};
struct {
unsigned :4;
unsigned DC2B0 :1;
unsigned DC2B1 :1;
};
} CCP2CONbits_t;
extern volatile CCP2CONbits_t CCP2CONbits @ 0xFBA;

# 3500
extern volatile unsigned short CCPR2 @ 0xFBB;

asm("CCPR2 equ 0FBBh");



extern volatile unsigned char CCPR2L @ 0xFBB;

asm("CCPR2L equ 0FBBh");



extern volatile unsigned char CCPR2H @ 0xFBC;

asm("CCPR2H equ 0FBCh");



extern volatile unsigned char CCP1CON @ 0xFBD;

asm("CCP1CON equ 0FBDh");


typedef union {
struct {
unsigned CCP1M :4;
unsigned DC1B :2;
};
struct {
unsigned CCP1M0 :1;
unsigned CCP1M1 :1;
unsigned CCP1M2 :1;
unsigned CCP1M3 :1;
unsigned CCP1Y :1;
unsigned CCP1X :1;
};
struct {
unsigned :4;
unsigned DC1B0 :1;
unsigned DC1B1 :1;
};
} CCP1CONbits_t;
extern volatile CCP1CONbits_t CCP1CONbits @ 0xFBD;

# 3596
extern volatile unsigned short CCPR1 @ 0xFBE;

asm("CCPR1 equ 0FBEh");



extern volatile unsigned char CCPR1L @ 0xFBE;

asm("CCPR1L equ 0FBEh");



extern volatile unsigned char CCPR1H @ 0xFBF;

asm("CCPR1H equ 0FBFh");



extern volatile unsigned char ADCON2 @ 0xFC0;

asm("ADCON2 equ 0FC0h");


typedef union {
struct {
unsigned ADCS :3;
unsigned ACQT :3;
unsigned :1;
unsigned ADFM :1;
};
struct {
unsigned ADCS0 :1;
unsigned ADCS1 :1;
unsigned ADCS2 :1;
unsigned ACQT0 :1;
unsigned ACQT1 :1;
unsigned ACQT2 :1;
};
} ADCON2bits_t;
extern volatile ADCON2bits_t ADCON2bits @ 0xFC0;

# 3684
extern volatile unsigned char ADCON1 @ 0xFC1;

asm("ADCON1 equ 0FC1h");


typedef union {
struct {
unsigned PCFG :4;
unsigned VCFG :2;
};
struct {
unsigned PCFG0 :1;
unsigned PCFG1 :1;
unsigned PCFG2 :1;
unsigned PCFG3 :1;
unsigned VCFG0 :1;
unsigned VCFG1 :1;
};
struct {
unsigned :3;
unsigned CHSN3 :1;
};
struct {
unsigned :4;
unsigned VCFG01 :1;
};
struct {
unsigned :5;
unsigned VCFG11 :1;
};
} ADCON1bits_t;
extern volatile ADCON1bits_t ADCON1bits @ 0xFC1;

# 3774
extern volatile unsigned char ADCON0 @ 0xFC2;

asm("ADCON0 equ 0FC2h");


typedef union {
struct {
unsigned :1;
unsigned GO_NOT_DONE :1;
};
struct {
unsigned ADON :1;
unsigned GO_nDONE :1;
unsigned CHS :4;
};
struct {
unsigned :1;
unsigned GO :1;
unsigned CHS0 :1;
unsigned CHS1 :1;
unsigned CHS2 :1;
unsigned CHS3 :1;
};
struct {
unsigned :1;
unsigned DONE :1;
};
struct {
unsigned :1;
unsigned NOT_DONE :1;
};
struct {
unsigned :1;
unsigned nDONE :1;
};
struct {
unsigned :1;
unsigned GO_DONE :1;
};
struct {
unsigned :1;
unsigned GODONE :1;
};
} ADCON0bits_t;
extern volatile ADCON0bits_t ADCON0bits @ 0xFC2;

# 3892
extern volatile unsigned short ADRES @ 0xFC3;

asm("ADRES equ 0FC3h");



extern volatile unsigned char ADRESL @ 0xFC3;

asm("ADRESL equ 0FC3h");



extern volatile unsigned char ADRESH @ 0xFC4;

asm("ADRESH equ 0FC4h");



extern volatile unsigned char SSPCON2 @ 0xFC5;

asm("SSPCON2 equ 0FC5h");


typedef union {
struct {
unsigned SEN :1;
unsigned RSEN :1;
unsigned PEN :1;
unsigned RCEN :1;
unsigned ACKEN :1;
unsigned ACKDT :1;
unsigned ACKSTAT :1;
unsigned GCEN :1;
};
} SSPCON2bits_t;
extern volatile SSPCON2bits_t SSPCON2bits @ 0xFC5;

# 3971
extern volatile unsigned char SSPCON1 @ 0xFC6;

asm("SSPCON1 equ 0FC6h");


typedef union {
struct {
unsigned SSPM :4;
unsigned CKP :1;
unsigned SSPEN :1;
unsigned SSPOV :1;
unsigned WCOL :1;
};
struct {
unsigned SSPM0 :1;
unsigned SSPM1 :1;
unsigned SSPM2 :1;
unsigned SSPM3 :1;
};
} SSPCON1bits_t;
extern volatile SSPCON1bits_t SSPCON1bits @ 0xFC6;

# 4040
extern volatile unsigned char SSPSTAT @ 0xFC7;

asm("SSPSTAT equ 0FC7h");


typedef union {
struct {
unsigned :2;
unsigned R_NOT_W :1;
};
struct {
unsigned :5;
unsigned D_NOT_A :1;
};
struct {
unsigned BF :1;
unsigned UA :1;
unsigned R_nW :1;
unsigned S :1;
unsigned P :1;
unsigned D_nA :1;
unsigned CKE :1;
unsigned SMP :1;
};
struct {
unsigned :2;
unsigned R :1;
unsigned :2;
unsigned D :1;
};
struct {
unsigned :2;
unsigned W :1;
unsigned :2;
unsigned A :1;
};
struct {
unsigned :2;
unsigned nW :1;
unsigned :2;
unsigned nA :1;
};
struct {
unsigned :2;
unsigned R_W :1;
unsigned :2;
unsigned D_A :1;
};
struct {
unsigned :2;
unsigned NOT_WRITE :1;
};
struct {
unsigned :5;
unsigned NOT_ADDRESS :1;
};
struct {
unsigned :2;
unsigned nWRITE :1;
unsigned :2;
unsigned nADDRESS :1;
};
struct {
unsigned :5;
unsigned DA :1;
};
struct {
unsigned :2;
unsigned RW :1;
};
struct {
unsigned :3;
unsigned START :1;
};
struct {
unsigned :4;
unsigned STOP :1;
};
struct {
unsigned :2;
unsigned NOT_W :1;
};
struct {
unsigned :5;
unsigned NOT_A :1;
};
} SSPSTATbits_t;
extern volatile SSPSTATbits_t SSPSTATbits @ 0xFC7;

# 4271
extern volatile unsigned char SSPADD @ 0xFC8;

asm("SSPADD equ 0FC8h");



extern volatile unsigned char SSPBUF @ 0xFC9;

asm("SSPBUF equ 0FC9h");



extern volatile unsigned char T2CON @ 0xFCA;

asm("T2CON equ 0FCAh");


typedef union {
struct {
unsigned T2CKPS :2;
unsigned TMR2ON :1;
unsigned TOUTPS :4;
};
struct {
unsigned T2CKPS0 :1;
unsigned T2CKPS1 :1;
unsigned :1;
unsigned T2OUTPS0 :1;
unsigned T2OUTPS1 :1;
unsigned T2OUTPS2 :1;
unsigned T2OUTPS3 :1;
};
} T2CONbits_t;
extern volatile T2CONbits_t T2CONbits @ 0xFCA;

# 4353
extern volatile unsigned char PR2 @ 0xFCB;

asm("PR2 equ 0FCBh");


extern volatile unsigned char MEMCON @ 0xFCB;

asm("MEMCON equ 0FCBh");


typedef union {
struct {
unsigned :7;
unsigned EBDIS :1;
};
struct {
unsigned :4;
unsigned WAIT0 :1;
};
struct {
unsigned :5;
unsigned WAIT1 :1;
};
struct {
unsigned WM0 :1;
};
struct {
unsigned :1;
unsigned WM1 :1;
};
} PR2bits_t;
extern volatile PR2bits_t PR2bits @ 0xFCB;

# 4412
typedef union {
struct {
unsigned :7;
unsigned EBDIS :1;
};
struct {
unsigned :4;
unsigned WAIT0 :1;
};
struct {
unsigned :5;
unsigned WAIT1 :1;
};
struct {
unsigned WM0 :1;
};
struct {
unsigned :1;
unsigned WM1 :1;
};
} MEMCONbits_t;
extern volatile MEMCONbits_t MEMCONbits @ 0xFCB;

# 4462
extern volatile unsigned char TMR2 @ 0xFCC;

asm("TMR2 equ 0FCCh");



extern volatile unsigned char T1CON @ 0xFCD;

asm("T1CON equ 0FCDh");


typedef union {
struct {
unsigned :2;
unsigned NOT_T1SYNC :1;
};
struct {
unsigned TMR1ON :1;
unsigned TMR1CS :1;
unsigned nT1SYNC :1;
unsigned T1OSCEN :1;
unsigned T1CKPS :2;
unsigned T1RUN :1;
unsigned RD16 :1;
};
struct {
unsigned :2;
unsigned T1SYNC :1;
unsigned :1;
unsigned T1CKPS0 :1;
unsigned T1CKPS1 :1;
};
struct {
unsigned :3;
unsigned SOSCEN :1;
};
struct {
unsigned :7;
unsigned T1RD16 :1;
};
} T1CONbits_t;
extern volatile T1CONbits_t T1CONbits @ 0xFCD;

# 4572
extern volatile unsigned short TMR1 @ 0xFCE;

asm("TMR1 equ 0FCEh");



extern volatile unsigned char TMR1L @ 0xFCE;

asm("TMR1L equ 0FCEh");



extern volatile unsigned char TMR1H @ 0xFCF;

asm("TMR1H equ 0FCFh");



extern volatile unsigned char RCON @ 0xFD0;

asm("RCON equ 0FD0h");


typedef union {
struct {
unsigned NOT_BOR :1;
};
struct {
unsigned :1;
unsigned NOT_POR :1;
};
struct {
unsigned :2;
unsigned NOT_PD :1;
};
struct {
unsigned :3;
unsigned NOT_TO :1;
};
struct {
unsigned :4;
unsigned NOT_RI :1;
};
struct {
unsigned nBOR :1;
unsigned nPOR :1;
unsigned nPD :1;
unsigned nTO :1;
unsigned nRI :1;
unsigned :1;
unsigned SBOREN :1;
unsigned IPEN :1;
};
struct {
unsigned BOR :1;
unsigned POR :1;
unsigned PD :1;
unsigned TO :1;
unsigned RI :1;
};
} RCONbits_t;
extern volatile RCONbits_t RCONbits @ 0xFD0;

# 4722
extern volatile unsigned char WDTCON @ 0xFD1;

asm("WDTCON equ 0FD1h");


typedef union {
struct {
unsigned SWDTEN :1;
};
struct {
unsigned SWDTE :1;
};
} WDTCONbits_t;
extern volatile WDTCONbits_t WDTCONbits @ 0xFD1;

# 4749
extern volatile unsigned char HLVDCON @ 0xFD2;

asm("HLVDCON equ 0FD2h");


extern volatile unsigned char LVDCON @ 0xFD2;

asm("LVDCON equ 0FD2h");


typedef union {
struct {
unsigned HLVDL :4;
unsigned HLVDEN :1;
unsigned IVRST :1;
unsigned :1;
unsigned VDIRMAG :1;
};
struct {
unsigned HLVDL0 :1;
unsigned HLVDL1 :1;
unsigned HLVDL2 :1;
unsigned HLVDL3 :1;
};
struct {
unsigned LVDL0 :1;
unsigned LVDL1 :1;
unsigned LVDL2 :1;
unsigned LVDL3 :1;
unsigned LVDEN :1;
unsigned IRVST :1;
};
struct {
unsigned LVV0 :1;
unsigned LVV1 :1;
unsigned LVV2 :1;
unsigned LVV3 :1;
unsigned :1;
unsigned BGST :1;
};
} HLVDCONbits_t;
extern volatile HLVDCONbits_t HLVDCONbits @ 0xFD2;

# 4888
typedef union {
struct {
unsigned HLVDL :4;
unsigned HLVDEN :1;
unsigned IVRST :1;
unsigned :1;
unsigned VDIRMAG :1;
};
struct {
unsigned HLVDL0 :1;
unsigned HLVDL1 :1;
unsigned HLVDL2 :1;
unsigned HLVDL3 :1;
};
struct {
unsigned LVDL0 :1;
unsigned LVDL1 :1;
unsigned LVDL2 :1;
unsigned LVDL3 :1;
unsigned LVDEN :1;
unsigned IRVST :1;
};
struct {
unsigned LVV0 :1;
unsigned LVV1 :1;
unsigned LVV2 :1;
unsigned LVV3 :1;
unsigned :1;
unsigned BGST :1;
};
} LVDCONbits_t;
extern volatile LVDCONbits_t LVDCONbits @ 0xFD2;

# 5018
extern volatile unsigned char OSCCON @ 0xFD3;

asm("OSCCON equ 0FD3h");


typedef union {
struct {
unsigned SCS :2;
unsigned IOFS :1;
unsigned OSTS :1;
unsigned IRCF :3;
unsigned IDLEN :1;
};
struct {
unsigned SCS0 :1;
unsigned SCS1 :1;
unsigned :2;
unsigned IRCF0 :1;
unsigned IRCF1 :1;
unsigned IRCF2 :1;
};
} OSCCONbits_t;
extern volatile OSCCONbits_t OSCCONbits @ 0xFD3;

# 5094
extern volatile unsigned char T0CON @ 0xFD5;

asm("T0CON equ 0FD5h");


typedef union {
struct {
unsigned T0PS :3;
unsigned PSA :1;
unsigned T0SE :1;
unsigned T0CS :1;
unsigned T08BIT :1;
unsigned TMR0ON :1;
};
struct {
unsigned T0PS0 :1;
unsigned T0PS1 :1;
unsigned T0PS2 :1;
unsigned :3;
unsigned T016BIT :1;
};
} T0CONbits_t;
extern volatile T0CONbits_t T0CONbits @ 0xFD5;

# 5170
extern volatile unsigned short TMR0 @ 0xFD6;

asm("TMR0 equ 0FD6h");



extern volatile unsigned char TMR0L @ 0xFD6;

asm("TMR0L equ 0FD6h");



extern volatile unsigned char TMR0H @ 0xFD7;

asm("TMR0H equ 0FD7h");



extern volatile unsigned char STATUS @ 0xFD8;

asm("STATUS equ 0FD8h");


typedef union {
struct {
unsigned C :1;
unsigned DC :1;
unsigned Z :1;
unsigned OV :1;
unsigned N :1;
};
struct {
unsigned CARRY :1;
};
struct {
unsigned :4;
unsigned NEGATIVE :1;
};
struct {
unsigned :3;
unsigned OVERFLOW :1;
};
struct {
unsigned :2;
unsigned ZERO :1;
};
} STATUSbits_t;
extern volatile STATUSbits_t STATUSbits @ 0xFD8;

# 5266
extern volatile unsigned short FSR2 @ 0xFD9;

asm("FSR2 equ 0FD9h");



extern volatile unsigned char FSR2L @ 0xFD9;

asm("FSR2L equ 0FD9h");



extern volatile unsigned char FSR2H @ 0xFDA;

asm("FSR2H equ 0FDAh");



extern volatile unsigned char PLUSW2 @ 0xFDB;

asm("PLUSW2 equ 0FDBh");



extern volatile unsigned char PREINC2 @ 0xFDC;

asm("PREINC2 equ 0FDCh");



extern volatile unsigned char POSTDEC2 @ 0xFDD;

asm("POSTDEC2 equ 0FDDh");



extern volatile unsigned char POSTINC2 @ 0xFDE;

asm("POSTINC2 equ 0FDEh");



extern volatile unsigned char INDF2 @ 0xFDF;

asm("INDF2 equ 0FDFh");



extern volatile unsigned char BSR @ 0xFE0;

asm("BSR equ 0FE0h");



extern volatile unsigned short FSR1 @ 0xFE1;

asm("FSR1 equ 0FE1h");



extern volatile unsigned char FSR1L @ 0xFE1;

asm("FSR1L equ 0FE1h");



extern volatile unsigned char FSR1H @ 0xFE2;

asm("FSR1H equ 0FE2h");



extern volatile unsigned char PLUSW1 @ 0xFE3;

asm("PLUSW1 equ 0FE3h");



extern volatile unsigned char PREINC1 @ 0xFE4;

asm("PREINC1 equ 0FE4h");



extern volatile unsigned char POSTDEC1 @ 0xFE5;

asm("POSTDEC1 equ 0FE5h");



extern volatile unsigned char POSTINC1 @ 0xFE6;

asm("POSTINC1 equ 0FE6h");



extern volatile unsigned char INDF1 @ 0xFE7;

asm("INDF1 equ 0FE7h");



extern volatile unsigned char WREG @ 0xFE8;

asm("WREG equ 0FE8h");

# 5379
extern volatile unsigned short FSR0 @ 0xFE9;

asm("FSR0 equ 0FE9h");



extern volatile unsigned char FSR0L @ 0xFE9;

asm("FSR0L equ 0FE9h");



extern volatile unsigned char FSR0H @ 0xFEA;

asm("FSR0H equ 0FEAh");



extern volatile unsigned char PLUSW0 @ 0xFEB;

asm("PLUSW0 equ 0FEBh");



extern volatile unsigned char PREINC0 @ 0xFEC;

asm("PREINC0 equ 0FECh");



extern volatile unsigned char POSTDEC0 @ 0xFED;

asm("POSTDEC0 equ 0FEDh");



extern volatile unsigned char POSTINC0 @ 0xFEE;

asm("POSTINC0 equ 0FEEh");



extern volatile unsigned char INDF0 @ 0xFEF;

asm("INDF0 equ 0FEFh");



extern volatile unsigned char INTCON3 @ 0xFF0;

asm("INTCON3 equ 0FF0h");


typedef union {
struct {
unsigned INT1IF :1;
unsigned INT2IF :1;
unsigned :1;
unsigned INT1IE :1;
unsigned INT2IE :1;
unsigned :1;
unsigned INT1IP :1;
unsigned INT2IP :1;
};
struct {
unsigned INT1F :1;
unsigned INT2F :1;
unsigned :1;
unsigned INT1E :1;
unsigned INT2E :1;
unsigned :1;
unsigned INT1P :1;
unsigned INT2P :1;
};
} INTCON3bits_t;
extern volatile INTCON3bits_t INTCON3bits @ 0xFF0;

# 5518
extern volatile unsigned char INTCON2 @ 0xFF1;

asm("INTCON2 equ 0FF1h");


typedef union {
struct {
unsigned :7;
unsigned NOT_RBPU :1;
};
struct {
unsigned RBIP :1;
unsigned :1;
unsigned TMR0IP :1;
unsigned :1;
unsigned INTEDG2 :1;
unsigned INTEDG1 :1;
unsigned INTEDG0 :1;
unsigned nRBPU :1;
};
struct {
unsigned :7;
unsigned RBPU :1;
};
} INTCON2bits_t;
extern volatile INTCON2bits_t INTCON2bits @ 0xFF1;

# 5587
extern volatile unsigned char INTCON @ 0xFF2;

asm("INTCON equ 0FF2h");


typedef union {
struct {
unsigned RBIF :1;
unsigned INT0IF :1;
unsigned TMR0IF :1;
unsigned RBIE :1;
unsigned INT0IE :1;
unsigned TMR0IE :1;
unsigned PEIE_GIEL :1;
unsigned GIE_GIEH :1;
};
struct {
unsigned :1;
unsigned INT0F :1;
unsigned T0IF :1;
unsigned :1;
unsigned INT0E :1;
unsigned T0IE :1;
unsigned PEIE :1;
unsigned GIE :1;
};
struct {
unsigned :6;
unsigned GIEL :1;
unsigned GIEH :1;
};
} INTCONbits_t;
extern volatile INTCONbits_t INTCONbits @ 0xFF2;

# 5703
extern volatile unsigned short PROD @ 0xFF3;

asm("PROD equ 0FF3h");



extern volatile unsigned char PRODL @ 0xFF3;

asm("PRODL equ 0FF3h");



extern volatile unsigned char PRODH @ 0xFF4;

asm("PRODH equ 0FF4h");



extern volatile unsigned char TABLAT @ 0xFF5;

asm("TABLAT equ 0FF5h");




extern volatile unsigned short long TBLPTR @ 0xFF6;


asm("TBLPTR equ 0FF6h");



extern volatile unsigned char TBLPTRL @ 0xFF6;

asm("TBLPTRL equ 0FF6h");



extern volatile unsigned char TBLPTRH @ 0xFF7;

asm("TBLPTRH equ 0FF7h");



extern volatile unsigned char TBLPTRU @ 0xFF8;

asm("TBLPTRU equ 0FF8h");




extern volatile unsigned short long PCLAT @ 0xFF9;


asm("PCLAT equ 0FF9h");



extern volatile unsigned short long PC @ 0xFF9;


asm("PC equ 0FF9h");



extern volatile unsigned char PCL @ 0xFF9;

asm("PCL equ 0FF9h");



extern volatile unsigned char PCLATH @ 0xFFA;

asm("PCLATH equ 0FFAh");



extern volatile unsigned char PCLATU @ 0xFFB;

asm("PCLATU equ 0FFBh");



extern volatile unsigned char STKPTR @ 0xFFC;

asm("STKPTR equ 0FFCh");


typedef union {
struct {
unsigned STKPTR :5;
unsigned :1;
unsigned STKUNF :1;
unsigned STKFUL :1;
};
struct {
unsigned STKPTR0 :1;
unsigned STKPTR1 :1;
unsigned STKPTR2 :1;
unsigned STKPTR3 :1;
unsigned STKPTR4 :1;
unsigned :2;
unsigned STKOVF :1;
};
struct {
unsigned SP0 :1;
unsigned SP1 :1;
unsigned SP2 :1;
unsigned SP3 :1;
unsigned SP4 :1;
};
} STKPTRbits_t;
extern volatile STKPTRbits_t STKPTRbits @ 0xFFC;

# 5890
extern volatile unsigned short long TOS @ 0xFFD;


asm("TOS equ 0FFDh");



extern volatile unsigned char TOSL @ 0xFFD;

asm("TOSL equ 0FFDh");



extern volatile unsigned char TOSH @ 0xFFE;

asm("TOSH equ 0FFEh");



extern volatile unsigned char TOSU @ 0xFFF;

asm("TOSU equ 0FFFh");

# 5921
extern volatile __bit ABDEN @ (((unsigned) &BAUDCON)*8) + 0;

extern volatile __bit ABDOVF @ (((unsigned) &BAUDCON)*8) + 7;

extern volatile __bit ACKDT @ (((unsigned) &SSPCON2)*8) + 5;

extern volatile __bit ACKEN @ (((unsigned) &SSPCON2)*8) + 4;

extern volatile __bit ACKSTAT @ (((unsigned) &SSPCON2)*8) + 6;

extern volatile __bit ACQT0 @ (((unsigned) &ADCON2)*8) + 3;

extern volatile __bit ACQT1 @ (((unsigned) &ADCON2)*8) + 4;

extern volatile __bit ACQT2 @ (((unsigned) &ADCON2)*8) + 5;

extern volatile __bit ADCS0 @ (((unsigned) &ADCON2)*8) + 0;

extern volatile __bit ADCS1 @ (((unsigned) &ADCON2)*8) + 1;

extern volatile __bit ADCS2 @ (((unsigned) &ADCON2)*8) + 2;

extern volatile __bit ADDEN @ (((unsigned) &RCSTA)*8) + 3;

extern volatile __bit ADEN @ (((unsigned) &RCSTA)*8) + 3;

extern volatile __bit ADFM @ (((unsigned) &ADCON2)*8) + 7;

extern volatile __bit ADIE @ (((unsigned) &PIE1)*8) + 6;

extern volatile __bit ADIF @ (((unsigned) &PIR1)*8) + 6;

extern volatile __bit ADIP @ (((unsigned) &IPR1)*8) + 6;

extern volatile __bit ADON @ (((unsigned) &ADCON0)*8) + 0;

extern volatile __bit AN10 @ (((unsigned) &PORTB)*8) + 1;

extern volatile __bit AN11 @ (((unsigned) &PORTB)*8) + 4;

extern volatile __bit AN12 @ (((unsigned) &PORTB)*8) + 0;

extern volatile __bit AN4 @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit AN8 @ (((unsigned) &PORTB)*8) + 2;

extern volatile __bit AN9 @ (((unsigned) &PORTB)*8) + 3;

extern volatile __bit BCLIE @ (((unsigned) &PIE2)*8) + 3;

extern volatile __bit BCLIF @ (((unsigned) &PIR2)*8) + 3;

extern volatile __bit BCLIP @ (((unsigned) &IPR2)*8) + 3;

extern volatile __bit BF @ (((unsigned) &SSPSTAT)*8) + 0;

extern volatile __bit BGST @ (((unsigned) &HLVDCON)*8) + 5;

extern volatile __bit BOR @ (((unsigned) &RCON)*8) + 0;

extern volatile __bit BRG16 @ (((unsigned) &BAUDCON)*8) + 3;

extern volatile __bit BRGH @ (((unsigned) &TXSTA)*8) + 2;

extern volatile __bit BRGH1 @ (((unsigned) &TXSTA)*8) + 2;

extern volatile __bit C1INV @ (((unsigned) &CMCON)*8) + 4;

extern volatile __bit C1OUT @ (((unsigned) &CMCON)*8) + 6;

extern volatile __bit C2INV @ (((unsigned) &CMCON)*8) + 5;

extern volatile __bit C2OUT @ (((unsigned) &CMCON)*8) + 7;

extern volatile __bit CARRY @ (((unsigned) &STATUS)*8) + 0;

extern volatile __bit CCP1 @ (((unsigned) &PORTC)*8) + 2;

extern volatile __bit CCP1IE @ (((unsigned) &PIE1)*8) + 2;

extern volatile __bit CCP1IF @ (((unsigned) &PIR1)*8) + 2;

extern volatile __bit CCP1IP @ (((unsigned) &IPR1)*8) + 2;

extern volatile __bit CCP1M0 @ (((unsigned) &CCP1CON)*8) + 0;

extern volatile __bit CCP1M1 @ (((unsigned) &CCP1CON)*8) + 1;

extern volatile __bit CCP1M2 @ (((unsigned) &CCP1CON)*8) + 2;

extern volatile __bit CCP1M3 @ (((unsigned) &CCP1CON)*8) + 3;

extern volatile __bit CCP1X @ (((unsigned) &CCP1CON)*8) + 5;

extern volatile __bit CCP1Y @ (((unsigned) &CCP1CON)*8) + 4;

extern volatile __bit CCP2IE @ (((unsigned) &PIE2)*8) + 0;

extern volatile __bit CCP2IF @ (((unsigned) &PIR2)*8) + 0;

extern volatile __bit CCP2IP @ (((unsigned) &IPR2)*8) + 0;

extern volatile __bit CCP2M0 @ (((unsigned) &CCP2CON)*8) + 0;

extern volatile __bit CCP2M1 @ (((unsigned) &CCP2CON)*8) + 1;

extern volatile __bit CCP2M2 @ (((unsigned) &CCP2CON)*8) + 2;

extern volatile __bit CCP2M3 @ (((unsigned) &CCP2CON)*8) + 3;

extern volatile __bit CCP2X @ (((unsigned) &CCP2CON)*8) + 5;

extern volatile __bit CCP2Y @ (((unsigned) &CCP2CON)*8) + 4;

extern volatile __bit CCP2_PA2 @ (((unsigned) &PORTB)*8) + 3;

extern volatile __bit CCP9E @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit CFGS @ (((unsigned) &EECON1)*8) + 6;

extern volatile __bit CHS0 @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit CHS1 @ (((unsigned) &ADCON0)*8) + 3;

extern volatile __bit CHS2 @ (((unsigned) &ADCON0)*8) + 4;

extern volatile __bit CHS3 @ (((unsigned) &ADCON0)*8) + 5;

extern volatile __bit CHSN3 @ (((unsigned) &ADCON1)*8) + 3;

extern volatile __bit CIS @ (((unsigned) &CMCON)*8) + 3;

extern volatile __bit CK @ (((unsigned) &PORTC)*8) + 6;

extern volatile __bit CKE @ (((unsigned) &SSPSTAT)*8) + 6;

extern volatile __bit CKP @ (((unsigned) &SSPCON1)*8) + 4;

extern volatile __bit CM0 @ (((unsigned) &CMCON)*8) + 0;

extern volatile __bit CM1 @ (((unsigned) &CMCON)*8) + 1;

extern volatile __bit CM2 @ (((unsigned) &CMCON)*8) + 2;

extern volatile __bit CMEN0 @ (((unsigned) &CMCON)*8) + 0;

extern volatile __bit CMEN1 @ (((unsigned) &CMCON)*8) + 1;

extern volatile __bit CMEN2 @ (((unsigned) &CMCON)*8) + 2;

extern volatile __bit CMIE @ (((unsigned) &PIE2)*8) + 6;

extern volatile __bit CMIF @ (((unsigned) &PIR2)*8) + 6;

extern volatile __bit CMIP @ (((unsigned) &IPR2)*8) + 6;

extern volatile __bit CREN @ (((unsigned) &RCSTA)*8) + 4;

extern volatile __bit CSRC @ (((unsigned) &TXSTA)*8) + 7;

extern volatile __bit CSRC1 @ (((unsigned) &TXSTA)*8) + 7;

extern volatile __bit CVR0 @ (((unsigned) &CVRCON)*8) + 0;

extern volatile __bit CVR1 @ (((unsigned) &CVRCON)*8) + 1;

extern volatile __bit CVR2 @ (((unsigned) &CVRCON)*8) + 2;

extern volatile __bit CVR3 @ (((unsigned) &CVRCON)*8) + 3;

extern volatile __bit CVREN @ (((unsigned) &CVRCON)*8) + 7;

extern volatile __bit CVROE @ (((unsigned) &CVRCON)*8) + 6;

extern volatile __bit CVROEN @ (((unsigned) &CVRCON)*8) + 6;

extern volatile __bit CVRR @ (((unsigned) &CVRCON)*8) + 5;

extern volatile __bit CVRSS @ (((unsigned) &CVRCON)*8) + 4;

extern volatile __bit DA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit DC @ (((unsigned) &STATUS)*8) + 1;

extern volatile __bit DC1B0 @ (((unsigned) &CCP1CON)*8) + 4;

extern volatile __bit DC1B1 @ (((unsigned) &CCP1CON)*8) + 5;

extern volatile __bit DC2B0 @ (((unsigned) &CCP2CON)*8) + 4;

extern volatile __bit DC2B1 @ (((unsigned) &CCP2CON)*8) + 5;

extern volatile __bit DONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit DT @ (((unsigned) &PORTC)*8) + 7;

extern volatile __bit D_A @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit D_NOT_A @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit D_nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit EBDIS @ (((unsigned) &PR2)*8) + 7;

extern volatile __bit ECCPAS0 @ (((unsigned) &ECCP1AS)*8) + 4;

extern volatile __bit ECCPAS1 @ (((unsigned) &ECCP1AS)*8) + 5;

extern volatile __bit ECCPAS2 @ (((unsigned) &ECCP1AS)*8) + 6;

extern volatile __bit ECCPASE @ (((unsigned) &ECCP1AS)*8) + 7;

extern volatile __bit EEFS @ (((unsigned) &EECON1)*8) + 6;

extern volatile __bit EEIE @ (((unsigned) &PIE2)*8) + 4;

extern volatile __bit EEIF @ (((unsigned) &PIR2)*8) + 4;

extern volatile __bit EEIP @ (((unsigned) &IPR2)*8) + 4;

extern volatile __bit EEPGD @ (((unsigned) &EECON1)*8) + 7;

extern volatile __bit FERR @ (((unsigned) &RCSTA)*8) + 2;

extern volatile __bit FREE @ (((unsigned) &EECON1)*8) + 4;

extern volatile __bit GCEN @ (((unsigned) &SSPCON2)*8) + 7;

extern volatile __bit GIE @ (((unsigned) &INTCON)*8) + 7;

extern volatile __bit GIEH @ (((unsigned) &INTCON)*8) + 7;

extern volatile __bit GIEL @ (((unsigned) &INTCON)*8) + 6;

extern volatile __bit GIE_GIEH @ (((unsigned) &INTCON)*8) + 7;

extern volatile __bit GO @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit GODONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit GO_DONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit GO_NOT_DONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit GO_nDONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit HLVDEN @ (((unsigned) &HLVDCON)*8) + 4;

extern volatile __bit HLVDIE @ (((unsigned) &PIE2)*8) + 2;

extern volatile __bit HLVDIF @ (((unsigned) &PIR2)*8) + 2;

extern volatile __bit HLVDIN @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit HLVDIP @ (((unsigned) &IPR2)*8) + 2;

extern volatile __bit HLVDL0 @ (((unsigned) &HLVDCON)*8) + 0;

extern volatile __bit HLVDL1 @ (((unsigned) &HLVDCON)*8) + 1;

extern volatile __bit HLVDL2 @ (((unsigned) &HLVDCON)*8) + 2;

extern volatile __bit HLVDL3 @ (((unsigned) &HLVDCON)*8) + 3;

extern volatile __bit IDLEN @ (((unsigned) &OSCCON)*8) + 7;

extern volatile __bit INT0 @ (((unsigned) &PORTB)*8) + 0;

extern volatile __bit INT0E @ (((unsigned) &INTCON)*8) + 4;

extern volatile __bit INT0F @ (((unsigned) &INTCON)*8) + 1;

extern volatile __bit INT0IE @ (((unsigned) &INTCON)*8) + 4;

extern volatile __bit INT0IF @ (((unsigned) &INTCON)*8) + 1;

extern volatile __bit INT1 @ (((unsigned) &PORTB)*8) + 1;

extern volatile __bit INT1E @ (((unsigned) &INTCON3)*8) + 3;

extern volatile __bit INT1F @ (((unsigned) &INTCON3)*8) + 0;

extern volatile __bit INT1IE @ (((unsigned) &INTCON3)*8) + 3;

extern volatile __bit INT1IF @ (((unsigned) &INTCON3)*8) + 0;

extern volatile __bit INT1IP @ (((unsigned) &INTCON3)*8) + 6;

extern volatile __bit INT1P @ (((unsigned) &INTCON3)*8) + 6;

extern volatile __bit INT2 @ (((unsigned) &PORTB)*8) + 2;

extern volatile __bit INT2E @ (((unsigned) &INTCON3)*8) + 4;

extern volatile __bit INT2F @ (((unsigned) &INTCON3)*8) + 1;

extern volatile __bit INT2IE @ (((unsigned) &INTCON3)*8) + 4;

extern volatile __bit INT2IF @ (((unsigned) &INTCON3)*8) + 1;

extern volatile __bit INT2IP @ (((unsigned) &INTCON3)*8) + 7;

extern volatile __bit INT2P @ (((unsigned) &INTCON3)*8) + 7;

extern volatile __bit INTEDG0 @ (((unsigned) &INTCON2)*8) + 6;

extern volatile __bit INTEDG1 @ (((unsigned) &INTCON2)*8) + 5;

extern volatile __bit INTEDG2 @ (((unsigned) &INTCON2)*8) + 4;

extern volatile __bit INTSRC @ (((unsigned) &OSCTUNE)*8) + 7;

extern volatile __bit IOFS @ (((unsigned) &OSCCON)*8) + 2;

extern volatile __bit IPEN @ (((unsigned) &RCON)*8) + 7;

extern volatile __bit IRCF0 @ (((unsigned) &OSCCON)*8) + 4;

extern volatile __bit IRCF1 @ (((unsigned) &OSCCON)*8) + 5;

extern volatile __bit IRCF2 @ (((unsigned) &OSCCON)*8) + 6;

extern volatile __bit IRVST @ (((unsigned) &HLVDCON)*8) + 5;

extern volatile __bit IVRST @ (((unsigned) &HLVDCON)*8) + 5;

extern volatile __bit KBI0 @ (((unsigned) &PORTB)*8) + 4;

extern volatile __bit KBI1 @ (((unsigned) &PORTB)*8) + 5;

extern volatile __bit KBI2 @ (((unsigned) &PORTB)*8) + 6;

extern volatile __bit KBI3 @ (((unsigned) &PORTB)*8) + 7;

extern volatile __bit LA0 @ (((unsigned) &LATA)*8) + 0;

extern volatile __bit LA1 @ (((unsigned) &LATA)*8) + 1;

extern volatile __bit LA2 @ (((unsigned) &LATA)*8) + 2;

extern volatile __bit LA3 @ (((unsigned) &LATA)*8) + 3;

extern volatile __bit LA4 @ (((unsigned) &LATA)*8) + 4;

extern volatile __bit LA5 @ (((unsigned) &LATA)*8) + 5;

extern volatile __bit LA6 @ (((unsigned) &LATA)*8) + 6;

extern volatile __bit LA7 @ (((unsigned) &LATA)*8) + 7;

extern volatile __bit LATA0 @ (((unsigned) &LATA)*8) + 0;

extern volatile __bit LATA1 @ (((unsigned) &LATA)*8) + 1;

extern volatile __bit LATA2 @ (((unsigned) &LATA)*8) + 2;

extern volatile __bit LATA3 @ (((unsigned) &LATA)*8) + 3;

extern volatile __bit LATA4 @ (((unsigned) &LATA)*8) + 4;

extern volatile __bit LATA5 @ (((unsigned) &LATA)*8) + 5;

extern volatile __bit LATA6 @ (((unsigned) &LATA)*8) + 6;

extern volatile __bit LATA7 @ (((unsigned) &LATA)*8) + 7;

extern volatile __bit LATB0 @ (((unsigned) &LATB)*8) + 0;

extern volatile __bit LATB1 @ (((unsigned) &LATB)*8) + 1;

extern volatile __bit LATB2 @ (((unsigned) &LATB)*8) + 2;

extern volatile __bit LATB3 @ (((unsigned) &LATB)*8) + 3;

extern volatile __bit LATB4 @ (((unsigned) &LATB)*8) + 4;

extern volatile __bit LATB5 @ (((unsigned) &LATB)*8) + 5;

extern volatile __bit LATB6 @ (((unsigned) &LATB)*8) + 6;

extern volatile __bit LATB7 @ (((unsigned) &LATB)*8) + 7;

extern volatile __bit LATC0 @ (((unsigned) &LATC)*8) + 0;

extern volatile __bit LATC1 @ (((unsigned) &LATC)*8) + 1;

extern volatile __bit LATC2 @ (((unsigned) &LATC)*8) + 2;

extern volatile __bit LATC3 @ (((unsigned) &LATC)*8) + 3;

extern volatile __bit LATC4 @ (((unsigned) &LATC)*8) + 4;

extern volatile __bit LATC5 @ (((unsigned) &LATC)*8) + 5;

extern volatile __bit LATC6 @ (((unsigned) &LATC)*8) + 6;

extern volatile __bit LATC7 @ (((unsigned) &LATC)*8) + 7;

extern volatile __bit LB0 @ (((unsigned) &LATB)*8) + 0;

extern volatile __bit LB1 @ (((unsigned) &LATB)*8) + 1;

extern volatile __bit LB2 @ (((unsigned) &LATB)*8) + 2;

extern volatile __bit LB3 @ (((unsigned) &LATB)*8) + 3;

extern volatile __bit LB4 @ (((unsigned) &LATB)*8) + 4;

extern volatile __bit LB5 @ (((unsigned) &LATB)*8) + 5;

extern volatile __bit LB6 @ (((unsigned) &LATB)*8) + 6;

extern volatile __bit LB7 @ (((unsigned) &LATB)*8) + 7;

extern volatile __bit LC0 @ (((unsigned) &LATC)*8) + 0;

extern volatile __bit LC1 @ (((unsigned) &LATC)*8) + 1;

extern volatile __bit LC2 @ (((unsigned) &LATC)*8) + 2;

extern volatile __bit LC3 @ (((unsigned) &LATC)*8) + 3;

extern volatile __bit LC4 @ (((unsigned) &LATC)*8) + 4;

extern volatile __bit LC5 @ (((unsigned) &LATC)*8) + 5;

extern volatile __bit LC6 @ (((unsigned) &LATC)*8) + 6;

extern volatile __bit LC7 @ (((unsigned) &LATC)*8) + 7;

extern volatile __bit LVDEN @ (((unsigned) &HLVDCON)*8) + 4;

extern volatile __bit LVDIE @ (((unsigned) &PIE2)*8) + 2;

extern volatile __bit LVDIF @ (((unsigned) &PIR2)*8) + 2;

extern volatile __bit LVDIN @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit LVDIP @ (((unsigned) &IPR2)*8) + 2;

extern volatile __bit LVDL0 @ (((unsigned) &HLVDCON)*8) + 0;

extern volatile __bit LVDL1 @ (((unsigned) &HLVDCON)*8) + 1;

extern volatile __bit LVDL2 @ (((unsigned) &HLVDCON)*8) + 2;

extern volatile __bit LVDL3 @ (((unsigned) &HLVDCON)*8) + 3;

extern volatile __bit LVV0 @ (((unsigned) &HLVDCON)*8) + 0;

extern volatile __bit LVV1 @ (((unsigned) &HLVDCON)*8) + 1;

extern volatile __bit LVV2 @ (((unsigned) &HLVDCON)*8) + 2;

extern volatile __bit LVV3 @ (((unsigned) &HLVDCON)*8) + 3;

extern volatile __bit MCLR @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit NEGATIVE @ (((unsigned) &STATUS)*8) + 4;

extern volatile __bit NOT_A @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit NOT_ADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit NOT_BOR @ (((unsigned) &RCON)*8) + 0;

extern volatile __bit NOT_DONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit NOT_MCLR @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit NOT_PD @ (((unsigned) &RCON)*8) + 2;

extern volatile __bit NOT_POR @ (((unsigned) &RCON)*8) + 1;

extern volatile __bit NOT_RBPU @ (((unsigned) &INTCON2)*8) + 7;

extern volatile __bit NOT_RI @ (((unsigned) &RCON)*8) + 4;

extern volatile __bit NOT_SS @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit NOT_T1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit NOT_T3SYNC @ (((unsigned) &T3CON)*8) + 2;

extern volatile __bit NOT_TO @ (((unsigned) &RCON)*8) + 3;

extern volatile __bit NOT_W @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit NOT_WRITE @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit OERR @ (((unsigned) &RCSTA)*8) + 1;

extern volatile __bit OSCFIE @ (((unsigned) &PIE2)*8) + 7;

extern volatile __bit OSCFIF @ (((unsigned) &PIR2)*8) + 7;

extern volatile __bit OSCFIP @ (((unsigned) &IPR2)*8) + 7;

extern volatile __bit OSTS @ (((unsigned) &OSCCON)*8) + 3;

extern volatile __bit OV @ (((unsigned) &STATUS)*8) + 3;

extern volatile __bit OVERFLOW @ (((unsigned) &STATUS)*8) + 3;

extern volatile __bit PA1 @ (((unsigned) &PORTC)*8) + 2;

extern volatile __bit PA2 @ (((unsigned) &PORTC)*8) + 1;

extern volatile __bit PC3E @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit PCFG0 @ (((unsigned) &ADCON1)*8) + 0;

extern volatile __bit PCFG1 @ (((unsigned) &ADCON1)*8) + 1;

extern volatile __bit PCFG2 @ (((unsigned) &ADCON1)*8) + 2;

extern volatile __bit PCFG3 @ (((unsigned) &ADCON1)*8) + 3;

extern volatile __bit PD @ (((unsigned) &RCON)*8) + 2;

extern volatile __bit PEIE @ (((unsigned) &INTCON)*8) + 6;

extern volatile __bit PEIE_GIEL @ (((unsigned) &INTCON)*8) + 6;

extern volatile __bit PEN @ (((unsigned) &SSPCON2)*8) + 2;

extern volatile __bit PGC @ (((unsigned) &PORTB)*8) + 6;

extern volatile __bit PGD @ (((unsigned) &PORTB)*8) + 7;

extern volatile __bit PGM @ (((unsigned) &PORTB)*8) + 5;

extern volatile __bit PLLEN @ (((unsigned) &OSCTUNE)*8) + 6;

extern volatile __bit POR @ (((unsigned) &RCON)*8) + 1;

extern volatile __bit PRSEN @ (((unsigned) &PWM1CON)*8) + 7;

extern volatile __bit PSA @ (((unsigned) &T0CON)*8) + 3;

extern volatile __bit PSSAC0 @ (((unsigned) &ECCP1AS)*8) + 2;

extern volatile __bit PSSAC1 @ (((unsigned) &ECCP1AS)*8) + 3;

extern volatile __bit __attribute__((__deprecated__)) RA0 @ (((unsigned) &PORTA)*8) + 0;

extern volatile __bit __attribute__((__deprecated__)) RA1 @ (((unsigned) &PORTA)*8) + 1;

extern volatile __bit __attribute__((__deprecated__)) RA2 @ (((unsigned) &PORTA)*8) + 2;

extern volatile __bit __attribute__((__deprecated__)) RA3 @ (((unsigned) &PORTA)*8) + 3;

extern volatile __bit __attribute__((__deprecated__)) RA4 @ (((unsigned) &PORTA)*8) + 4;

extern volatile __bit __attribute__((__deprecated__)) RA5 @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit __attribute__((__deprecated__)) RA6 @ (((unsigned) &PORTA)*8) + 6;

extern volatile __bit __attribute__((__deprecated__)) RA7 @ (((unsigned) &PORTA)*8) + 7;

extern volatile __bit __attribute__((__deprecated__)) RB0 @ (((unsigned) &PORTB)*8) + 0;

extern volatile __bit __attribute__((__deprecated__)) RB1 @ (((unsigned) &PORTB)*8) + 1;

extern volatile __bit __attribute__((__deprecated__)) RB2 @ (((unsigned) &PORTB)*8) + 2;

extern volatile __bit __attribute__((__deprecated__)) RB3 @ (((unsigned) &PORTB)*8) + 3;

extern volatile __bit __attribute__((__deprecated__)) RB4 @ (((unsigned) &PORTB)*8) + 4;

extern volatile __bit __attribute__((__deprecated__)) RB5 @ (((unsigned) &PORTB)*8) + 5;

extern volatile __bit __attribute__((__deprecated__)) RB6 @ (((unsigned) &PORTB)*8) + 6;

extern volatile __bit __attribute__((__deprecated__)) RB7 @ (((unsigned) &PORTB)*8) + 7;

extern volatile __bit RBIE @ (((unsigned) &INTCON)*8) + 3;

extern volatile __bit RBIF @ (((unsigned) &INTCON)*8) + 0;

extern volatile __bit RBIP @ (((unsigned) &INTCON2)*8) + 0;

extern volatile __bit RBPU @ (((unsigned) &INTCON2)*8) + 7;

extern volatile __bit __attribute__((__deprecated__)) RC0 @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit __attribute__((__deprecated__)) RC1 @ (((unsigned) &PORTC)*8) + 1;

extern volatile __bit RC1IE @ (((unsigned) &PIE1)*8) + 5;

extern volatile __bit RC1IF @ (((unsigned) &PIR1)*8) + 5;

extern volatile __bit RC1IP @ (((unsigned) &IPR1)*8) + 5;

extern volatile __bit __attribute__((__deprecated__)) RC2 @ (((unsigned) &PORTC)*8) + 2;

extern volatile __bit __attribute__((__deprecated__)) RC3 @ (((unsigned) &PORTC)*8) + 3;

extern volatile __bit __attribute__((__deprecated__)) RC4 @ (((unsigned) &PORTC)*8) + 4;

extern volatile __bit __attribute__((__deprecated__)) RC5 @ (((unsigned) &PORTC)*8) + 5;

extern volatile __bit __attribute__((__deprecated__)) RC6 @ (((unsigned) &PORTC)*8) + 6;

extern volatile __bit __attribute__((__deprecated__)) RC7 @ (((unsigned) &PORTC)*8) + 7;

extern volatile __bit RC8_9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RC9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RCD8 @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit RCEN @ (((unsigned) &SSPCON2)*8) + 3;

extern volatile __bit RCIDL @ (((unsigned) &BAUDCON)*8) + 6;

extern volatile __bit RCIE @ (((unsigned) &PIE1)*8) + 5;

extern volatile __bit RCIF @ (((unsigned) &PIR1)*8) + 5;

extern volatile __bit RCIP @ (((unsigned) &IPR1)*8) + 5;

extern volatile __bit RCMT @ (((unsigned) &BAUDCON)*8) + 6;

extern volatile __bit RD @ (((unsigned) &EECON1)*8) + 0;

extern volatile __bit RD163 @ (((unsigned) &T3CON)*8) + 7;

extern volatile __bit RE3 @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit RI @ (((unsigned) &RCON)*8) + 4;

extern volatile __bit RJPU @ (((unsigned) &PORTA)*8) + 7;

extern volatile __bit RSEN @ (((unsigned) &SSPCON2)*8) + 1;

extern volatile __bit RW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit RX @ (((unsigned) &PORTC)*8) + 7;

extern volatile __bit RX9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RX9D @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit RXCKP @ (((unsigned) &BAUDCON)*8) + 5;

extern volatile __bit RXDTP @ (((unsigned) &BAUDCON)*8) + 5;

extern volatile __bit R_NOT_W @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit R_W @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit R_nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit SBOREN @ (((unsigned) &RCON)*8) + 6;

extern volatile __bit SCK @ (((unsigned) &PORTC)*8) + 3;

extern volatile __bit SCKP @ (((unsigned) &BAUDCON)*8) + 4;

extern volatile __bit SCL @ (((unsigned) &PORTC)*8) + 3;

extern volatile __bit SCS0 @ (((unsigned) &OSCCON)*8) + 0;

extern volatile __bit SCS1 @ (((unsigned) &OSCCON)*8) + 1;

extern volatile __bit SDA @ (((unsigned) &PORTC)*8) + 4;

extern volatile __bit SDI @ (((unsigned) &PORTC)*8) + 4;

extern volatile __bit SDO @ (((unsigned) &PORTC)*8) + 5;

extern volatile __bit SEN @ (((unsigned) &SSPCON2)*8) + 0;

extern volatile __bit SENDB @ (((unsigned) &TXSTA)*8) + 3;

extern volatile __bit SENDB1 @ (((unsigned) &TXSTA)*8) + 3;

extern volatile __bit SMP @ (((unsigned) &SSPSTAT)*8) + 7;

extern volatile __bit SOSCEN @ (((unsigned) &T1CON)*8) + 3;

extern volatile __bit SOSCEN3 @ (((unsigned) &T3CON)*8) + 3;

extern volatile __bit SP0 @ (((unsigned) &STKPTR)*8) + 0;

extern volatile __bit SP1 @ (((unsigned) &STKPTR)*8) + 1;

extern volatile __bit SP2 @ (((unsigned) &STKPTR)*8) + 2;

extern volatile __bit SP3 @ (((unsigned) &STKPTR)*8) + 3;

extern volatile __bit SP4 @ (((unsigned) &STKPTR)*8) + 4;

extern volatile __bit SPEN @ (((unsigned) &RCSTA)*8) + 7;

extern volatile __bit SREN @ (((unsigned) &RCSTA)*8) + 5;

extern volatile __bit SRENA @ (((unsigned) &RCSTA)*8) + 5;

extern volatile __bit SS @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit SSPEN @ (((unsigned) &SSPCON1)*8) + 5;

extern volatile __bit SSPIE @ (((unsigned) &PIE1)*8) + 3;

extern volatile __bit SSPIF @ (((unsigned) &PIR1)*8) + 3;

extern volatile __bit SSPIP @ (((unsigned) &IPR1)*8) + 3;

extern volatile __bit SSPM0 @ (((unsigned) &SSPCON1)*8) + 0;

extern volatile __bit SSPM1 @ (((unsigned) &SSPCON1)*8) + 1;

extern volatile __bit SSPM2 @ (((unsigned) &SSPCON1)*8) + 2;

extern volatile __bit SSPM3 @ (((unsigned) &SSPCON1)*8) + 3;

extern volatile __bit SSPOV @ (((unsigned) &SSPCON1)*8) + 6;

extern volatile __bit START @ (((unsigned) &SSPSTAT)*8) + 3;

extern volatile __bit STKFUL @ (((unsigned) &STKPTR)*8) + 7;

extern volatile __bit STKOVF @ (((unsigned) &STKPTR)*8) + 7;

extern volatile __bit STKPTR0 @ (((unsigned) &STKPTR)*8) + 0;

extern volatile __bit STKPTR1 @ (((unsigned) &STKPTR)*8) + 1;

extern volatile __bit STKPTR2 @ (((unsigned) &STKPTR)*8) + 2;

extern volatile __bit STKPTR3 @ (((unsigned) &STKPTR)*8) + 3;

extern volatile __bit STKPTR4 @ (((unsigned) &STKPTR)*8) + 4;

extern volatile __bit STKUNF @ (((unsigned) &STKPTR)*8) + 6;

extern volatile __bit STOP @ (((unsigned) &SSPSTAT)*8) + 4;

extern volatile __bit SWDTE @ (((unsigned) &WDTCON)*8) + 0;

extern volatile __bit SWDTEN @ (((unsigned) &WDTCON)*8) + 0;

extern volatile __bit SYNC @ (((unsigned) &TXSTA)*8) + 4;

extern volatile __bit SYNC1 @ (((unsigned) &TXSTA)*8) + 4;

extern volatile __bit T016BIT @ (((unsigned) &T0CON)*8) + 6;

extern volatile __bit T08BIT @ (((unsigned) &T0CON)*8) + 6;

extern volatile __bit T0CKI @ (((unsigned) &PORTA)*8) + 4;

extern volatile __bit T0CS @ (((unsigned) &T0CON)*8) + 5;

extern volatile __bit T0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit T0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit T0PS0 @ (((unsigned) &T0CON)*8) + 0;

extern volatile __bit T0PS1 @ (((unsigned) &T0CON)*8) + 1;

extern volatile __bit T0PS2 @ (((unsigned) &T0CON)*8) + 2;

extern volatile __bit T0SE @ (((unsigned) &T0CON)*8) + 4;

extern volatile __bit T13CKI @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit T1CKI @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit T1CKPS0 @ (((unsigned) &T1CON)*8) + 4;

extern volatile __bit T1CKPS1 @ (((unsigned) &T1CON)*8) + 5;

extern volatile __bit T1OSCEN @ (((unsigned) &T1CON)*8) + 3;

extern volatile __bit T1OSI @ (((unsigned) &PORTC)*8) + 1;

extern volatile __bit T1OSO @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit T1RD16 @ (((unsigned) &T1CON)*8) + 7;

extern volatile __bit T1RUN @ (((unsigned) &T1CON)*8) + 6;

extern volatile __bit T1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit T2CKPS0 @ (((unsigned) &T2CON)*8) + 0;

extern volatile __bit T2CKPS1 @ (((unsigned) &T2CON)*8) + 1;

extern volatile __bit T2OUTPS0 @ (((unsigned) &T2CON)*8) + 3;

extern volatile __bit T2OUTPS1 @ (((unsigned) &T2CON)*8) + 4;

extern volatile __bit T2OUTPS2 @ (((unsigned) &T2CON)*8) + 5;

extern volatile __bit T2OUTPS3 @ (((unsigned) &T2CON)*8) + 6;

extern volatile __bit T3CCP1 @ (((unsigned) &T3CON)*8) + 3;

extern volatile __bit T3CCP2 @ (((unsigned) &T3CON)*8) + 6;

extern volatile __bit T3CKPS0 @ (((unsigned) &T3CON)*8) + 4;

extern volatile __bit T3CKPS1 @ (((unsigned) &T3CON)*8) + 5;

extern volatile __bit T3RD16 @ (((unsigned) &T3CON)*8) + 7;

extern volatile __bit T3SYNC @ (((unsigned) &T3CON)*8) + 2;

extern volatile __bit TMR0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit TMR0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit TMR0IP @ (((unsigned) &INTCON2)*8) + 2;

extern volatile __bit TMR0ON @ (((unsigned) &T0CON)*8) + 7;

extern volatile __bit TMR1CS @ (((unsigned) &T1CON)*8) + 1;

extern volatile __bit TMR1IE @ (((unsigned) &PIE1)*8) + 0;

extern volatile __bit TMR1IF @ (((unsigned) &PIR1)*8) + 0;

extern volatile __bit TMR1IP @ (((unsigned) &IPR1)*8) + 0;

extern volatile __bit TMR1ON @ (((unsigned) &T1CON)*8) + 0;

extern volatile __bit TMR2IE @ (((unsigned) &PIE1)*8) + 1;

extern volatile __bit TMR2IF @ (((unsigned) &PIR1)*8) + 1;

extern volatile __bit TMR2IP @ (((unsigned) &IPR1)*8) + 1;

extern volatile __bit TMR2ON @ (((unsigned) &T2CON)*8) + 2;

extern volatile __bit TMR3CS @ (((unsigned) &T3CON)*8) + 1;

extern volatile __bit TMR3IE @ (((unsigned) &PIE2)*8) + 1;

extern volatile __bit TMR3IF @ (((unsigned) &PIR2)*8) + 1;

extern volatile __bit TMR3IP @ (((unsigned) &IPR2)*8) + 1;

extern volatile __bit TMR3ON @ (((unsigned) &T3CON)*8) + 0;

extern volatile __bit TO @ (((unsigned) &RCON)*8) + 3;

extern volatile __bit TRISA0 @ (((unsigned) &TRISA)*8) + 0;

extern volatile __bit TRISA1 @ (((unsigned) &TRISA)*8) + 1;

extern volatile __bit TRISA2 @ (((unsigned) &TRISA)*8) + 2;

extern volatile __bit TRISA3 @ (((unsigned) &TRISA)*8) + 3;

extern volatile __bit TRISA4 @ (((unsigned) &TRISA)*8) + 4;

extern volatile __bit TRISA5 @ (((unsigned) &TRISA)*8) + 5;

extern volatile __bit TRISA6 @ (((unsigned) &TRISA)*8) + 6;

extern volatile __bit TRISA7 @ (((unsigned) &TRISA)*8) + 7;

extern volatile __bit TRISB0 @ (((unsigned) &TRISB)*8) + 0;

extern volatile __bit TRISB1 @ (((unsigned) &TRISB)*8) + 1;

extern volatile __bit TRISB2 @ (((unsigned) &TRISB)*8) + 2;

extern volatile __bit TRISB3 @ (((unsigned) &TRISB)*8) + 3;

extern volatile __bit TRISB4 @ (((unsigned) &TRISB)*8) + 4;

extern volatile __bit TRISB5 @ (((unsigned) &TRISB)*8) + 5;

extern volatile __bit TRISB6 @ (((unsigned) &TRISB)*8) + 6;

extern volatile __bit TRISB7 @ (((unsigned) &TRISB)*8) + 7;

extern volatile __bit TRISC0 @ (((unsigned) &TRISC)*8) + 0;

extern volatile __bit TRISC1 @ (((unsigned) &TRISC)*8) + 1;

extern volatile __bit TRISC2 @ (((unsigned) &TRISC)*8) + 2;

extern volatile __bit TRISC3 @ (((unsigned) &TRISC)*8) + 3;

extern volatile __bit TRISC4 @ (((unsigned) &TRISC)*8) + 4;

extern volatile __bit TRISC5 @ (((unsigned) &TRISC)*8) + 5;

extern volatile __bit TRISC6 @ (((unsigned) &TRISC)*8) + 6;

extern volatile __bit TRISC7 @ (((unsigned) &TRISC)*8) + 7;

extern volatile __bit TRMT @ (((unsigned) &TXSTA)*8) + 1;

extern volatile __bit TRMT1 @ (((unsigned) &TXSTA)*8) + 1;

extern volatile __bit TUN0 @ (((unsigned) &OSCTUNE)*8) + 0;

extern volatile __bit TUN1 @ (((unsigned) &OSCTUNE)*8) + 1;

extern volatile __bit TUN2 @ (((unsigned) &OSCTUNE)*8) + 2;

extern volatile __bit TUN3 @ (((unsigned) &OSCTUNE)*8) + 3;

extern volatile __bit TUN4 @ (((unsigned) &OSCTUNE)*8) + 4;

extern volatile __bit TX @ (((unsigned) &PORTC)*8) + 6;

extern volatile __bit TX1IE @ (((unsigned) &PIE1)*8) + 4;

extern volatile __bit TX1IF @ (((unsigned) &PIR1)*8) + 4;

extern volatile __bit TX1IP @ (((unsigned) &IPR1)*8) + 4;

extern volatile __bit TX8_9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX91 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9D @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TX9D1 @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXCKP @ (((unsigned) &BAUDCON)*8) + 4;

extern volatile __bit TXD8 @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXEN @ (((unsigned) &TXSTA)*8) + 5;

extern volatile __bit TXEN1 @ (((unsigned) &TXSTA)*8) + 5;

extern volatile __bit TXIE @ (((unsigned) &PIE1)*8) + 4;

extern volatile __bit TXIF @ (((unsigned) &PIR1)*8) + 4;

extern volatile __bit TXIP @ (((unsigned) &IPR1)*8) + 4;

extern volatile __bit UA @ (((unsigned) &SSPSTAT)*8) + 1;

extern volatile __bit ULPWUIN @ (((unsigned) &PORTA)*8) + 0;

extern volatile __bit VCFG0 @ (((unsigned) &ADCON1)*8) + 4;

extern volatile __bit VCFG01 @ (((unsigned) &ADCON1)*8) + 4;

extern volatile __bit VCFG1 @ (((unsigned) &ADCON1)*8) + 5;

extern volatile __bit VCFG11 @ (((unsigned) &ADCON1)*8) + 5;

extern volatile __bit VDIRMAG @ (((unsigned) &HLVDCON)*8) + 7;

extern volatile __bit VPP @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit W4E @ (((unsigned) &BAUDCON)*8) + 1;

extern volatile __bit WAIT0 @ (((unsigned) &PR2)*8) + 4;

extern volatile __bit WAIT1 @ (((unsigned) &PR2)*8) + 5;

extern volatile __bit WCOL @ (((unsigned) &SSPCON1)*8) + 7;

extern volatile __bit WM0 @ (((unsigned) &PR2)*8) + 0;

extern volatile __bit WM1 @ (((unsigned) &PR2)*8) + 1;

extern volatile __bit WR @ (((unsigned) &EECON1)*8) + 1;

extern volatile __bit WREN @ (((unsigned) &EECON1)*8) + 2;

extern volatile __bit WRERR @ (((unsigned) &EECON1)*8) + 3;

extern volatile __bit WUE @ (((unsigned) &BAUDCON)*8) + 1;

extern volatile __bit ZERO @ (((unsigned) &STATUS)*8) + 2;

extern volatile __bit nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nBOR @ (((unsigned) &RCON)*8) + 0;

extern volatile __bit nDONE @ (((unsigned) &ADCON0)*8) + 1;

extern volatile __bit nMCLR @ (((unsigned) &PORTE)*8) + 3;

extern volatile __bit nPD @ (((unsigned) &RCON)*8) + 2;

extern volatile __bit nPOR @ (((unsigned) &RCON)*8) + 1;

extern volatile __bit nRBPU @ (((unsigned) &INTCON2)*8) + 7;

extern volatile __bit nRI @ (((unsigned) &RCON)*8) + 4;

extern volatile __bit nSS @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit nT1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit nT3SYNC @ (((unsigned) &T3CON)*8) + 2;

extern volatile __bit nTO @ (((unsigned) &RCON)*8) + 3;

extern volatile __bit nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit nWRITE @ (((unsigned) &SSPSTAT)*8) + 2;

# 18 "/opt/microchip/xc8/v1.37/include/pic18.h"
__attribute__((__unsupported__("The " "flash_write" " routine is no longer supported. Please use the MPLAB X MCC."))) void flash_write(const unsigned char *, unsigned int, __far unsigned char *);
__attribute__((__unsupported__("The " "EraseFlash" " routine is no longer supported. Please use the MPLAB X MCC."))) void EraseFlash(unsigned long startaddr, unsigned long endaddr);


# 42
#pragma intrinsic(__nop)
extern void __nop(void);


# 156
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);
#pragma intrinsic(_delaywdt)
extern __nonreentrant void _delaywdt(unsigned long);
#pragma intrinsic(_delay3)
extern __nonreentrant void _delay3(unsigned char);

# 4 "/opt/microchip/xc8/v1.37/include/__size_t.h"
typedef unsigned size_t;

# 7 "/opt/microchip/xc8/v1.37/include/stdarg.h"
typedef void * va_list[1];

#pragma intrinsic(__va_start)
extern void * __va_start(void);

#pragma intrinsic(__va_arg)
extern void * __va_arg(void *, ...);

# 43 "/opt/microchip/xc8/v1.37/include/stdio.h"
struct __prbuf
{
char * ptr;
void (* func)(char);
};

# 29 "/opt/microchip/xc8/v1.37/include/errno.h"
extern int errno;

# 12 "/opt/microchip/xc8/v1.37/include/conio.h"
extern void init_uart(void);

extern char getch(void);
extern char getche(void);
extern void putch(char);
extern void ungetch(char);

extern __bit kbhit(void);

# 23
extern char * cgets(char *);
extern void cputs(const char *);

# 88 "/opt/microchip/xc8/v1.37/include/stdio.h"
extern int cprintf(char *, ...);
#pragma printf_check(cprintf)



extern int _doprnt(struct __prbuf *, const register char *, register va_list);


# 180
#pragma printf_check(vprintf) const
#pragma printf_check(vsprintf) const

extern char * gets(char *);
extern int puts(const char *);
extern int scanf(const char *, ...) __attribute__((unsupported("scanf() is not supported by this compiler")));
extern int sscanf(const char *, const char *, ...) __attribute__((unsupported("sscanf() is not supported by this compiler")));
extern int vprintf(const char *, va_list) __attribute__((unsupported("vprintf() is not supported by this compiler")));
extern int vsprintf(char *, const char *, va_list) __attribute__((unsupported("vsprintf() is not supported by this compiler")));
extern int vscanf(const char *, va_list ap) __attribute__((unsupported("vscanf() is not supported by this compiler")));
extern int vsscanf(const char *, const char *, va_list) __attribute__((unsupported("vsscanf() is not supported by this compiler")));

#pragma printf_check(printf) const
#pragma printf_check(sprintf) const
extern int sprintf(char *, const char *, ...);
extern int printf(const char *, ...);

# 14 "/opt/microchip/xc8/v1.37/include/string.h"
extern void * memcpy(void *, const void *, size_t);
extern void * memmove(void *, const void *, size_t);
extern void * memset(void *, int, size_t);

# 34
extern char * strcat(char *, const char *);
extern char * strcpy(char *, const char *);
extern char * strncat(char *, const char *, size_t);
extern char * strncpy(char *, const char *, size_t);
extern char * strdup(const char *);
extern char * strtok(char *, const char *);


extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int stricmp(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern int strnicmp(const char *, const char *, size_t);
extern void * memchr(const void *, int, size_t);
extern size_t strcspn(const char *, const char *);
extern char * strpbrk(const char *, const char *);
extern size_t strspn(const char *, const char *);
extern char * strstr(const char *, const char *);
extern char * stristr(const char *, const char *);
extern char * strerror(int);
extern size_t strlen(const char *);
extern char * strchr(const char *, int);
extern char * strichr(const char *, int);
extern char * strrchr(const char *, int);
extern char * strrichr(const char *, int);


# 9 "prog.c"
#pragma config OSC = HSPLL
#pragma config FCMEN = OFF
#pragma config IESO = ON


#pragma config PWRT = ON
#pragma config BOREN = SBORDIS
#pragma config BORV = 3


#pragma config WDT = ON
#pragma config WDTPS = 1024


#pragma config CCP2MX = PORTC
#pragma config PBADEN = OFF
#pragma config LPT1OSC = ON
#pragma config MCLRE = OFF


#pragma config STVREN = ON
#pragma config LVP = OFF
#pragma config XINST = OFF


#pragma config CP0 = OFF
#pragma config CP1 = OFF
#pragma config CP2 = OFF
#pragma config CP3 = OFF


#pragma config CPB = OFF
#pragma config CPD = OFF


#pragma config WRT0 = OFF
#pragma config WRT1 = OFF
#pragma config WRT2 = OFF
#pragma config WRT3 = OFF


#pragma config WRTC = OFF
#pragma config WRTB = OFF
#pragma config WRTD = OFF


#pragma config EBTR0 = OFF
#pragma config EBTR1 = OFF
#pragma config EBTR2 = OFF
#pragma config EBTR3 = OFF


#pragma config EBTRB = OFF

# 89
unsigned char digits[32];
unsigned char digits_system_message[32];

typedef struct {
unsigned blink : 1;
unsigned modifided : 1;
} digits_atributes;

digits_atributes digitsAtrib[32];
digits_atributes digitsAtrib_system_message[32];
unsigned long int _systemCounter = 0;
long int Clock;
long int lastClock;
int clock_delta = 0;
long int Minutes = 0;

unsigned int LCD_ON_TIMEOUT = 8000;
volatile unsigned char KeyCode;
unsigned int CorrectTimeConst;
unsigned int AdressOfNextStartCell = (8 * 48);
unsigned long int NearTimeStart;
unsigned long int NearTimeStop;
unsigned int CurrentReadingCell = 0;
unsigned char CurrentSignalsData = 0;
volatile unsigned char SignalsOut = 0;
volatile unsigned char SignalsForInd = 0;

struct {
unsigned DetailModeOfViewSheduler : 1;
unsigned RelevanceOfNextStartCell : 1;
unsigned LCD_Light_On : 1;
unsigned LCD_Power_On : 1;
unsigned LockSignals : 1;
unsigned IsLCDModified : 1;
unsigned GlobalBlink : 1;
unsigned GSM_Connected : 1;
unsigned ActiveCall : 1;
unsigned IncommingCall : 1;
unsigned UnreadSystemMessage : 1;
unsigned UnprocessedIncommingUartData : 1;
unsigned SignalsAreChanged : 1;
unsigned RemoteControlIsEnabled : 1;
unsigned TimeSource : 2;
unsigned SendTimeRequest : 1;
unsigned UsartExchangeEnabled : 1;
unsigned StatusIsRequested : 1;
unsigned IsUartOK : 1;
unsigned IsTemperatureRead : 1;
unsigned Is1wireOK : 1;
unsigned UseGSM : 1;
} flags;

unsigned char cMinutes = 0;
unsigned char cHours = 0;
unsigned char cWeekDay = 1;
unsigned char cDays = 1;
unsigned char cMonths = 1;
unsigned char cYears = 1;

unsigned char CurrentSignals = 0;
unsigned char GlobalBlinkCycleTime = 70;

typedef struct {
unsigned blink : 1;
unsigned const_symbol : 1;
} symbol_properties;

enum InputType {
aa,
Aa,
AA
};

enum Devices {
NON = 0,
RTC = 1,
GSM = 2
};

enum InputLang {
English,
Russian,
Numeric
};

enum NoYes {
No,
Yes
};

enum CurrentShowing {
csTime,
csTemperature
};

typedef struct {
unsigned Aa : 2;
unsigned Language : 2;
unsigned NotClearInd : 1;
unsigned ReturnAfterInput : 1;
unsigned BlockCharSet : 1;
unsigned PhoneKeyboard : 1;
unsigned char InputChar;
} input_text_props;

typedef struct {
symbol_properties props;
unsigned char number;
unsigned char symbol;
unsigned char index;
} SymbolData;

typedef struct {
SymbolData *Time [5];
SymbolData *WeekDay [1];
SymbolData *Date [10];
unsigned char TimeSource;
} TimeEditData;

typedef struct {
unsigned char name[17];
unsigned char phone [14];
unsigned char blocked[1];
unsigned char filled[1];
} Phone;

# 244
unsigned char buff_string_8 [256];
unsigned char buff_string_9 [256];
unsigned char buff_string_10 [256];
unsigned char buff_string_11 [256];

unsigned char *IncommingBuffer[(3 + 1)];

unsigned char *OutcommingBuffer = (0);

const unsigned char StandardAnswer_OK [] = "OK";

const unsigned char StandardAnswer_CLOCK [] = "+CCLK: \"\x10\x10/\x10\x10/\x10\x10,\x10\x10:\x10\x10:\x10\x10\x10\x10\x10\"";

const unsigned char StandardAnswer_INCCALL [] = "+CLIP: \"\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\",145,\"\",,\"\",0";
const unsigned char StandardAnswer_BUSY [] = "BUSY";
const unsigned char StandardAnswer_NO_ANSWER [] = "NO ANSWER";
const unsigned char StandardAnswer_NO_CARRIER [] = "NO CARRIER";
const unsigned char StandardAnswer_NO_DIALTONE [] = "NO DIALTONE";
const unsigned char StandardAnswer_DTMF [] = "+DTMF:\x10";
const unsigned char StandardAnswer_ERROR [] = "ERROR";
const unsigned char StandardAnswer_NORMAL_POWER_DOWN [] = "NORMAL POWER DOWN";
const unsigned char StandardAnswer_STAT [] = "+CPAS: \x10";

# 273
unsigned char Clock_from_GSM[30];
unsigned char Incomming_Call_Data[36];
unsigned char Incomming_DTMF_Data[8];
unsigned char DTMF_Symbol;

unsigned char SMS [512];
unsigned char active_phone [14];

int temperature = 0;
unsigned char temp_drob = 0;
unsigned char current_showing = csTime;




void main2(void);
void lcd_init(void);
void lcd_on(void);
void lcd_off(void);
void SendArrayToLCD(unsigned char A[], char B, char C);
void ParseTime(long int TimeValue, unsigned int *Time, unsigned char *Day);
void ParseDataRecord(unsigned long int Data, unsigned int *TimeStart, unsigned int *TimeStop, unsigned char *Days, unsigned char *Signals);
void EEWR(unsigned int adress, unsigned char data);
void Scheduler(unsigned int StartFrom);
void SchedulerNew(unsigned int StartFrom);
void SignalsOnOff(void);
void FillMinutes(void);
unsigned char EERD(unsigned int adress);
unsigned long int ReadFourBytesEE(unsigned int adress);
unsigned char *GetDayOfWeek(unsigned char day);
unsigned char EditSchedule(unsigned int adress, unsigned int SourceOfRecord);
unsigned int FindNextTimeStart(unsigned long int *TimeFrom);
unsigned char getNumChar(unsigned char num);
void I2CInit(void);
void I2CStart(void);
void I2CStop(void);
void I2CRestart(void);
void I2CAck(void);
void I2CNak(void);
void I2CWait(void);
void I2CSend(unsigned char dat);
void OutputString(unsigned char * stringData, unsigned char line, unsigned char position, unsigned char trasnsfer_line);
unsigned char I2CRead(void);
void ReadTime();
void WriteTime(unsigned long int lClock, unsigned char days, unsigned char months, unsigned char years);
unsigned char BCD_to_DEC(unsigned char BCD);
unsigned char DEC_to_BCD(unsigned char DEC);
void FillArrayFromEEPROM(unsigned char * container, unsigned int adress_start, unsigned int quantity);
void WriteArrayToEEPROM(unsigned char * container, unsigned int adress_start, unsigned int quantity);
void ReadDataOfCell(unsigned char *CellsData, unsigned long int *Data, unsigned int TargetAdress);
void CleanStringArray(unsigned char *myArray, unsigned int size, unsigned char settingData);
unsigned long int getSystemTimePoint(void);
unsigned char testTimePoint(unsigned long int point, unsigned long int value);
void PhonebookEdit(void);
unsigned char *InputText(unsigned char *text, input_text_props *_props, unsigned char capacity);
unsigned char Select_OK_NO(unsigned char *text);
unsigned char FindIncommingData(unsigned char *regexp, unsigned char *container, int history_index);
unsigned char _FindIncommingData_interrupt(unsigned char *regexp, unsigned char *container, int history_index);
char ShowMenu(unsigned char *menu[], unsigned char item);
void OutputSystemMessage(unsigned char *stringData);
void SendCommandToUSART(unsigned char *command, unsigned char wait);
unsigned char USART_Speed_Choise(void);
void Save_USART_SpeedNumber(unsigned char speed);
void Settings(void);
unsigned char Read_USART_SpeedNumber(void);
unsigned int GetStringLength(unsigned char *container);
unsigned int _GetStringLength_interr(unsigned char *container);
void Format_EEPROM_Memory(unsigned int first_cell, unsigned int last_cell, unsigned char interactive);
unsigned char GetDayOfWeekByDate(unsigned char _year, unsigned char _mounth, unsigned char _day);
void SendSMS(unsigned char *, unsigned char *);


unsigned char Init_1wire() {
unsigned char b = 0;
TRISA0 = 1;
_delay((unsigned long)((20)*(40000000/4000000.0)));
TRISA0 = 0;
_delay((unsigned long)((500)*(40000000/4000000.0)));
TRISA0 = 1;
_delay((unsigned long)((65)*(40000000/4000000.0)));
b = LA0;
_delay((unsigned long)((450)*(40000000/4000000.0)));

return !(b == 1);
}

void TX_1wire(unsigned char cmd) {
unsigned char temp = 0;
unsigned char i = 0;
temp = cmd;
for (i = 0; i < 8; i++) {
if (temp & 0x01) {
TRISA0 = 0;
_delay((unsigned long)((5)*(40000000/4000000.0)));
TRISA0 = 1;
_delay((unsigned long)((70)*(40000000/4000000.0)));
} else {
TRISA0 = 0;
_delay((unsigned long)((70)*(40000000/4000000.0)));
TRISA0 = 1;
_delay((unsigned long)((5)*(40000000/4000000.0)));
}
temp >>= 1;
}
}

unsigned char RX_1wire() {
unsigned char d = 0;
for (unsigned char i = 0; i < 8; i++) {
TRISA0 = 0;
_delay((unsigned long)((6)*(40000000/4000000.0)));
TRISA0 = 1;
_delay((unsigned long)((4)*(40000000/4000000.0)));
d >>= 1;
if (LA0 == 1) d |= 0x80;
_delay((unsigned long)((60)*(40000000/4000000.0)));
}
return d;
}


unsigned char get_temp() {
unsigned char init;
unsigned char temp1 = 0;
unsigned char temp2 = 0;

flags.Is1wireOK = 0;
flags.IsTemperatureRead = 0;

init = Init_1wire();

if (init) {
flags.Is1wireOK = 1;

TX_1wire(0xCC);
TX_1wire(0x44);

long int tClock = Clock;
while (Clock - tClock < 100);

} else {
return 0;
}

init = Init_1wire();

if (init) {
TX_1wire(0xCC);
TX_1wire(0xBE);

temp1 = RX_1wire();
temp2 = RX_1wire();

flags.IsTemperatureRead = 1;
} else {
return 0;
}
temp_drob = temp1 & 0b00001111;
temp_drob = ((temp_drob * 6) + 2) / 10;
temp1 >>= 4;
unsigned char sign = temp2 & 0x80;
temp2 <<= 4;
temp2 &= 0b01110000;
temp2 |= temp1;

if (sign) {
temperature = 127 - temp2;
temp_drob = 10 - temp_drob;
if (temp_drob == 10) {
temp_drob = 0;
temperature++;
}
temperature *= -1;
} else {
temperature = temp2;
}
return 1;
}

unsigned char getDigit(char line, char symbol) {
return *(digits + 16 * line + symbol);
}

void setDigit(char line, char symbol, unsigned char data) {
unsigned char value = data;
unsigned char value0 = *(digits + 16 * line + symbol);
(*(digitsAtrib + 16 * line + symbol)).modifided = (*(digitsAtrib + 16 * line + symbol)).modifided > 0 || (value != value0);
flags.IsLCDModified = flags.IsLCDModified || (value != value0);
*(digits + 16 * line + symbol) = value;
}

void setBlink(char line, char symbol, unsigned char value) {
if (value != 0) {
(*(digitsAtrib + 16 * line + symbol)).blink = 1;
} else {
(*(digitsAtrib + 16 * line + symbol)).blink = 0;
}
(*(digitsAtrib + 16 * line + symbol)).modifided = 1;
flags.IsLCDModified = 1;
}

void clrInd() {
for (char line = 0; line < 2; line++) {
for (char symb = 0; symb < 16; symb++) {
*(digits + line * 16 + symb) = ' ';
(*(digitsAtrib + line * 16 + symb)).blink = 0;
(*(digitsAtrib + line * 16 + symb)).modifided = 1;
}
}
flags.IsLCDModified = 1;
}

void CalculateClockDelta(long int newTime) {
if (lastClock != 0) {
clock_delta = clock_delta + (newTime - Clock) / (newTime / 100 - lastClock / 100);
}
lastClock = newTime;
}

unsigned int GetUnicodeSymbol(unsigned char symb) {
switch (symb) {
case 0x00: return 0x0000;
case 0x01: return 0x0001;
case 0x02: return 0x0002;
case 0x03: return 0x0003;
case 0x04: return 0x0004;
case 0x05: return 0x0005;
case 0x06: return 0x0006;
case 0x07: return 0x0007;
case 0x08: return 0x0008;
case 0x09: return 0x0009;
case 0x0A: return 0x000A;
case 0x0B: return 0x000B;
case 0x0C: return 0x000C;
case 0x0D: return 0x000D;
case 0x0E: return 0x000E;
case 0x0F: return 0x000F;
case 0x10: return 0x0010;
case 0x11: return 0x0011;
case 0x12: return 0x0012;
case 0x13: return 0x0013;
case 0x14: return 0x0014;
case 0x15: return 0x0015;
case 0x16: return 0x0016;
case 0x17: return 0x0017;
case 0x18: return 0x0018;
case 0x19: return 0x0019;
case 0x1A: return 0x001A;
case 0x1B: return 0x001B;
case 0x1C: return 0x001C;
case 0x1D: return 0x001D;
case 0x1E: return 0x001E;
case 0x1F: return 0x001F;
case 0x20: return 0x0020;
case 0x21: return 0x0021;
case 0x22: return 0x0022;
case 0x23: return 0x0023;
case 0x24: return 0x0024;
case 0x25: return 0x0025;
case 0x26: return 0x0026;
case 0x27: return 0x0027;
case 0x28: return 0x0028;
case 0x29: return 0x0029;
case 0x2A: return 0x002A;
case 0x2B: return 0x002B;
case 0x2C: return 0x002C;
case 0x2D: return 0x002D;
case 0x2E: return 0x002E;
case 0x2F: return 0x002F;
case 0x30: return 0x0030;
case 0x31: return 0x0031;
case 0x32: return 0x0032;
case 0x33: return 0x0033;
case 0x34: return 0x0034;
case 0x35: return 0x0035;
case 0x36: return 0x0036;
case 0x37: return 0x0037;
case 0x38: return 0x0038;
case 0x39: return 0x0039;
case 0x3A: return 0x003A;
case 0x3B: return 0x003B;
case 0x3C: return 0x003C;
case 0x3D: return 0x003D;
case 0x3E: return 0x003E;
case 0x3F: return 0x003F;
case 0x40: return 0x0040;
case 0x41: return 0x0041;
case 0x42: return 0x0042;
case 0x43: return 0x0043;
case 0x44: return 0x0044;
case 0x45: return 0x0045;
case 0x46: return 0x0046;
case 0x47: return 0x0047;
case 0x48: return 0x0048;
case 0x49: return 0x0049;
case 0x4A: return 0x004A;
case 0x4B: return 0x004B;
case 0x4C: return 0x004C;
case 0x4D: return 0x004D;
case 0x4E: return 0x004E;
case 0x4F: return 0x004F;
case 0x50: return 0x0050;
case 0x51: return 0x0051;
case 0x52: return 0x0052;
case 0x53: return 0x0053;
case 0x54: return 0x0054;
case 0x55: return 0x0055;
case 0x56: return 0x0056;
case 0x57: return 0x0057;
case 0x58: return 0x0058;
case 0x59: return 0x0059;
case 0x5A: return 0x005A;
case 0x5B: return 0x005B;
case 0x5C: return 0x005C;
case 0x5D: return 0x005D;
case 0x5E: return 0x005E;
case 0x5F: return 0x005F;
case 0x60: return 0x0060;
case 0x61: return 0x0061;
case 0x62: return 0x0062;
case 0x63: return 0x0063;
case 0x64: return 0x0064;
case 0x65: return 0x0065;
case 0x66: return 0x0066;
case 0x67: return 0x0067;
case 0x68: return 0x0068;
case 0x69: return 0x0069;
case 0x6A: return 0x006A;
case 0x6B: return 0x006B;
case 0x6C: return 0x006C;
case 0x6D: return 0x006D;
case 0x6E: return 0x006E;
case 0x6F: return 0x006F;
case 0x70: return 0x0070;
case 0x71: return 0x0071;
case 0x72: return 0x0072;
case 0x73: return 0x0073;
case 0x74: return 0x0074;
case 0x75: return 0x0075;
case 0x76: return 0x0076;
case 0x77: return 0x0077;
case 0x78: return 0x0078;
case 0x79: return 0x0079;
case 0x7A: return 0x007A;
case 0x7B: return 0x007B;
case 0x7C: return 0x007C;
case 0x7D: return 0x007D;
case 0x7E: return 0x007E;
case 0x7F: return 0x007F;
case 0x80: return 0x0402;
case 0x81: return 0x0403;
case 0x82: return 0x201A;
case 0x83: return 0x0453;
case 0x84: return 0x201E;
case 0x85: return 0x2026;
case 0x86: return 0x2020;
case 0x87: return 0x2021;
case 0x88: return 0x20AC;
case 0x89: return 0x2030;
case 0x8A: return 0x0409;
case 0x8B: return 0x2039;
case 0x8C: return 0x040A;
case 0x8D: return 0x040C;
case 0x8E: return 0x040B;
case 0x8F: return 0x040F;
case 0x90: return 0x0452;
case 0x91: return 0x2018;
case 0x92: return 0x2019;
case 0x93: return 0x201C;
case 0x94: return 0x201D;
case 0x95: return 0x2022;
case 0x96: return 0x2013;
case 0x97: return 0x2014;
case 0x98: return 0x003F;
case 0x99: return 0x2122;
case 0x9A: return 0x0459;
case 0x9B: return 0x203A;
case 0x9C: return 0x045A;
case 0x9D: return 0x045C;
case 0x9E: return 0x045B;
case 0x9F: return 0x045F;
case 0xA0: return 0x00A0;
case 0xA1: return 0x040E;
case 0xA2: return 0x045E;
case 0xA3: return 0x0408;
case 0xA4: return 0x00A4;
case 0xA5: return 0x0490;
case 0xA6: return 0x00A6;
case 0xA7: return 0x00A7;
case 0xA8: return 0x0401;
case 0xA9: return 0x00A9;
case 0xAA: return 0x0404;
case 0xAB: return 0x00AB;
case 0xAC: return 0x00AC;
case 0xAD: return 0x00AD;
case 0xAE: return 0x00AE;
case 0xAF: return 0x0407;
case 0xB0: return 0x00B0;
case 0xB1: return 0x00B1;
case 0xB2: return 0x0406;
case 0xB3: return 0x0456;
case 0xB4: return 0x0491;
case 0xB5: return 0x00B5;
case 0xB6: return 0x00B6;
case 0xB7: return 0x00B7;
case 0xB8: return 0x0451;
case 0xB9: return 0x2116;
case 0xBA: return 0x0454;
case 0xBB: return 0x00BB;
case 0xBC: return 0x0458;
case 0xBD: return 0x0405;
case 0xBE: return 0x0455;
case 0xBF: return 0x0457;
case 0xC0: return 0x0410;
case 0xC1: return 0x0411;
case 0xC2: return 0x0412;
case 0xC3: return 0x0413;
case 0xC4: return 0x0414;
case 0xC5: return 0x0415;
case 0xC6: return 0x0416;
case 0xC7: return 0x0417;
case 0xC8: return 0x0418;
case 0xC9: return 0x0419;
case 0xCA: return 0x041A;
case 0xCB: return 0x041B;
case 0xCC: return 0x041C;
case 0xCD: return 0x041D;
case 0xCE: return 0x041E;
case 0xCF: return 0x041F;
case 0xD0: return 0x0420;
case 0xD1: return 0x0421;
case 0xD2: return 0x0422;
case 0xD3: return 0x0423;
case 0xD4: return 0x0424;
case 0xD5: return 0x0425;
case 0xD6: return 0x0426;
case 0xD7: return 0x0427;
case 0xD8: return 0x0428;
case 0xD9: return 0x0429;
case 0xDA: return 0x042A;
case 0xDB: return 0x042B;
case 0xDC: return 0x042C;
case 0xDD: return 0x042D;
case 0xDE: return 0x042E;
case 0xDF: return 0x042F;
case 0xE0: return 0x0430;
case 0xE1: return 0x0431;
case 0xE2: return 0x0432;
case 0xE3: return 0x0433;
case 0xE4: return 0x0434;
case 0xE5: return 0x0435;
case 0xE6: return 0x0436;
case 0xE7: return 0x0437;
case 0xE8: return 0x0438;
case 0xE9: return 0x0439;
case 0xEA: return 0x043A;
case 0xEB: return 0x043B;
case 0xEC: return 0x043C;
case 0xED: return 0x043D;
case 0xEE: return 0x043E;
case 0xEF: return 0x043F;
case 0xF0: return 0x0440;
case 0xF1: return 0x0441;
case 0xF2: return 0x0442;
case 0xF3: return 0x0443;
case 0xF4: return 0x0444;
case 0xF5: return 0x0445;
case 0xF6: return 0x0446;
case 0xF7: return 0x0447;
case 0xF8: return 0x0448;
case 0xF9: return 0x0449;
case 0xFA: return 0x044A;
case 0xFB: return 0x044B;
case 0xFC: return 0x044C;
case 0xFD: return 0x044D;
case 0xFE: return 0x044E;
case 0xFF: return 0x044F;
default: return 0x003F;
}
}

unsigned char GetTimeSource() {
flags.TimeSource = EERD(1022);
return flags.TimeSource;
}

void SetTimeSource(unsigned char time_source) {
EEWR(1022, time_source);
flags.TimeSource = time_source;
}

unsigned char getLcdCodeOfChar(unsigned char dig) {
switch (dig) {
case ' ': return 0x20;
case '0': return 0x30;
case '1': return 0x31;
case '2': return 0x32;
case '3': return 0x33;
case '4': return 0x34;
case '5': return 0x35;
case '6': return 0x36;
case '7': return 0x37;
case '8': return 0x38;
case '9': return 0x39;
case '-': return 0x2D;
case '': return 0x2D;
case '!': return 0x21;
case '"': return 0x22;
case '#': return 0x23;
case '$': return 0x24;
case '%': return 0x25;
case '&': return 0x26;
case '(': return 0x28;
case ')': return 0x29;
case '*': return 0x2A;
case ',': return 0x2C;
case '.': return 0x2E;
case '/': return 0x2F;
case ':': return 0x3A;
case ';': return 0x3B;
case '?': return 0x3F;
case '@': return 0x40;
case '[': return 0x5B;
case ']': return 0x5D;
case '^': return 0x5E;
case '_': return 0x5F;
case '`': return 0x60;
case '': return 0x27;
case '+': return 0x2B;
case '<': return 0x3C;
case '=': return 0x3D;
case '>': return 0x3E;
case '': return 0xEF;
case '': return 0xC8;
case '': return 0xC9;
case '\\':return 0x2F;
case '~': return 0xE9;

case 'A': return 0x41;
case 'a': return 0x61;
case 'B': return 0x42;
case 'b': return 0x62;
case 'C': return 0x43;
case 'c': return 0x63;
case 'D': return 0x44;
case 'd': return 0x64;
case 'E': return 0x45;
case 'e': return 0x65;
case 'F': return 0x46;
case 'f': return 0x66;
case 'G': return 0x47;
case 'g': return 0x67;
case 'H': return 0x48;
case 'h': return 0x68;
case 'I': return 0x49;
case 'i': return 0x69;
case 'J': return 0x4A;
case 'j': return 0x6A;
case 'K': return 0x4B;
case 'k': return 0x6B;
case 'L': return 0x4C;
case 'l': return 0x6C;
case 'M': return 0x4D;
case 'm': return 0x6D;
case 'N': return 0x4E;
case 'n': return 0x6E;
case '': return 0xCC;
case 'O': return 0x4F;
case 'o': return 0x6F;
case 'P': return 0x50;
case 'p': return 0x70;
case 'Q': return 0x51;
case 'q': return 0x71;
case 'R': return 0x52;
case 'r': return 0x72;
case 'S': return 0x53;
case 's': return 0x73;
case 'T': return 0x54;
case 't': return 0x74;
case 'U': return 0x55;
case 'u': return 0x75;
case 'V': return 0x56;
case 'v': return 0x76;
case 'W': return 0x57;
case 'w': return 0x77;
case 'X': return 0x58;
case 'x': return 0x78;
case 'Y': return 0x59;
case 'y': return 0x79;
case 'Z': return 0x5A;
case 'z': return 0x7A;
case '': return 0x41;
case '': return 0x61;
case '': return 0xA0;
case '': return 0xB2;
case '': return 0x42;
case '': return 0xB3;
case '': return 0xA1;
case '': return 0xB4;
case '': return 0xE0;
case '': return 0xE3;
case '': return 0x45;
case '': return 0x65;
case '': return 0xA2;
case '': return 0xB5;
case '': return 0xA3;
case '': return 0xB6;
case '': return 0xA4;
case '': return 0xB7;
case '': return 0xA5;
case '': return 0xB8;
case '': return 0xA6;
case '': return 0xB9;
case '': return 0x4B;
case '': return 0xBA;
case '': return 0xA7;
case '': return 0xBB;
case '': return 0xBC;
case '': return 0x4D;
case '': return 0x48;
case '': return 0xBD;
case '': return 0x4F;
case '': return 0x6F;
case '': return 0xA8;
case '': return 0xBE;
case '': return 0x50;
case '': return 0x70;
case '': return 0x43;
case '': return 0x63;
case '': return 0xBF;
case '': return 0x54;
case '': return 0xA9;
case '': return 0x79;
case '': return 0xAA;
case '': return 0xE4;
case '': return 0x58;
case '': return 0x78;
case '': return 0xE1;
case '': return 0xE5;
case '': return 0xAB;
case '': return 0xC0;
case '': return 0xAC;
case '': return 0xC1;
case '': return 0xE2;
case '': return 0xE6;
case '': return 0xAD;
case '': return 0xC2;
case '': return 0xAE;
case '': return 0xC3;
case '': return 0xC4;
case '': return 0xC4;
case '': return 0xAF;
case '': return 0xC5;
case '': return 0xB0;
case '': return 0xC6;
case '': return 0xB1;
case '': return 0xC7;
case '\x07': return 0xED;
case '\x08': return 0xDD;

default: return 0x3F;
}
}

unsigned char ConvertCharToNumeric(unsigned char symbol) {
switch (symbol) {
case '0': return 0;
case '1': return 1;
case '2': return 2;
case '3': return 3;
case '4': return 4;
case '5': return 5;
case '6': return 6;
case '7': return 7;
case '8': return 8;
case '9': return 9;
default: return 0;
}
}

unsigned char CheckoutRegisterOfSymbol(unsigned char dig) {
switch (dig) {
case 'A': return 'a';
case 'a': return 'A';
case 'B': return 'b';
case 'b': return 'B';
case 'C': return 'c';
case 'c': return 'C';
case 'D': return 'd';
case 'd': return 'D';
case 'E': return 'e';
case 'e': return 'E';
case 'F': return 'f';
case 'f': return 'F';
case 'G': return 'g';
case 'g': return 'G';
case 'H': return 'h';
case 'h': return 'H';
case 'I': return 'i';
case 'i': return 'I';
case 'J': return 'j';
case 'j': return 'J';
case 'K': return 'k';
case 'k': return 'K';
case 'L': return 'l';
case 'l': return 'L';
case 'M': return 'm';
case 'm': return 'M';
case 'N': return 'n';
case 'n': return 'N';
case 'O': return 'o';
case 'o': return 'O';
case 'P': return 'p';
case 'p': return 'P';
case 'Q': return 'q';
case 'q': return 'Q';
case 'R': return 'r';
case 'r': return 'R';
case 'S': return 's';
case 's': return 'S';
case 'T': return 't';
case 't': return 'T';
case 'U': return 'u';
case 'u': return 'U';
case 'V': return 'v';
case 'v': return 'V';
case 'W': return 'w';
case 'w': return 'W';
case 'X': return 'x';
case 'x': return 'X';
case 'Y': return 'y';
case 'y': return 'Y';
case 'Z': return 'z';
case 'z': return 'Z';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
case '': return '';
default: return dig;
}
}

unsigned char entNum(char borderDown, char borderUp) {
if (KeyCode >= 30 && KeyCode <= 39) {
char KeyValue = KeyCode - 30;
if (borderDown <= KeyValue && borderUp >= KeyValue) {
KeyCode = 0;
return (unsigned char) KeyValue;
} else return 255;
} else return 255;
}

void NumericToString(long int n, unsigned char * mySring, unsigned char size) {
if (mySring[size - 1] == '\0') {
size--;
}
unsigned char displacement = 1;
unsigned char negative = 0;
if (n < 0) {
negative = 1;
n *= -1;
}
do {
mySring[size - displacement] = getNumChar(n % 10);
n /= 10;
displacement++;
} while ((size - (displacement - 1) > 0) && (n > 0));

if (negative && (size - (displacement - 1) > 0)) {
mySring[size - displacement] = '-';
}
}

void NumericToHEXString(long int n, unsigned char * mySring, unsigned char size) {
if (mySring[size - 1] == '\0') {
size--;
}
unsigned char displacement = 1;
do {
mySring[size - displacement] = getNumChar(n % 16);
n /= 16;
displacement++;
} while ((size - (displacement - 1) > 0) && (n > 0));
}

unsigned char *GetDayOfWeek(unsigned char day) {
if (day == 1) {
return "";
} else if (day == 2) {
return "";
} else if (day == 3) {
return "";
} else if (day == 4) {
return "";
} else if (day == 5) {
return "";
} else if (day == 6) {
return "";
} else if (day == 7) {
return "";
}
return "??";
}

void TimeToInd() {

if (flags.SignalsAreChanged) {
flags.SignalsAreChanged = 0;
clrInd();
}

if (KeyCode == 32 && (AdressOfNextStartCell != (8 * 48) || flags.DetailModeOfViewSheduler)) {
KeyCode = 0;
clrInd();
flags.DetailModeOfViewSheduler = !flags.DetailModeOfViewSheduler;
}
if (KeyCode == 45 && AdressOfNextStartCell != (8 * 48) && flags.DetailModeOfViewSheduler) {
KeyCode = 0;
Scheduler(AdressOfNextStartCell);
}
if (!flags.RelevanceOfNextStartCell) {
NearTimeStart = Clock;
AdressOfNextStartCell = FindNextTimeStart(&NearTimeStart);
if (flags.DetailModeOfViewSheduler) {
flags.DetailModeOfViewSheduler = 0;
clrInd();
}
flags.RelevanceOfNextStartCell = 1;
}

if (AdressOfNextStartCell == (8 * 48) || !flags.DetailModeOfViewSheduler) {
unsigned char SignalsFinal = CurrentSignals | SignalsForInd;
if (SignalsFinal > 0) {

unsigned char D [] = "   ";
for (unsigned char i = 1; i < 4; i++) {
unsigned char SignalOn = SignalsFinal % 2;
SignalsFinal /= 2;
if (SignalOn == 1) {
D[0] = D[1];
D[1] = D[2];
D[2] = getNumChar(i);
}
}
OutputString(D, 0, 13, 1);
}

unsigned char TimeData [] = "--:--:--";
long int temp = Clock / 100;
TimeData[7] = getNumChar(temp % 10);
temp /= 10;
TimeData[6] = getNumChar(temp % 6);
temp /= 6;
TimeData[4] = getNumChar(temp % 10);
temp /= 10;
TimeData[3] = getNumChar(temp % 6);
temp /= 6;
unsigned char day = temp / 24 + 1;
temp %= 24;
TimeData[1] = getNumChar(temp % 10);
TimeData[0] = getNumChar(temp / 10);


if (current_showing == csTemperature) {
static long int tClock = 0;
long int ElapsedTime = Clock - tClock;
if (ElapsedTime >= 200) {
tClock = Clock;
current_showing = csTime;
}
}

SignalsFinal = CurrentSignals | SignalsForInd;
if (current_showing == csTime) {
OutputString(TimeData, 0, (SignalsFinal == 7) ? 4 : 5, 0);
} else if (current_showing == csTemperature) {
unsigned char tString [9];
if (flags.IsTemperatureRead) {
strcpy(tString, "    .  C");
NumericToString(temp_drob, tString, 6);
NumericToString(temperature, tString, 4);
} else {
strcpy(tString, "  ERROR ");
}
OutputString(tString, 0, (SignalsFinal == 7) ? 4 : 5, 0);
}
OutputString(GetDayOfWeek(day), 0, (SignalsFinal == 7) ? 1 : 2, 0);

if(flags.GSM_Connected){
char s [] = " ";
s[0] = '\x08';
OutputString(s, 0, 0, 0);
}
}

if (flags.LockSignals && !flags.DetailModeOfViewSheduler) {
OutputString(" .", 1, 0, 0);
return;
}


if (AdressOfNextStartCell != (8 * 48)) {

unsigned char DataArray[] = "                ";
DataArray[0] = '\x07';

char line = 1;
if (flags.DetailModeOfViewSheduler) {
line = 0;
DataArray[5] = '';
}

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, AdressOfNextStartCell);

unsigned int TimeStart;
unsigned int TimeStop;
unsigned char Days;
unsigned char Signals;
ParseDataRecord(Data, &TimeStart, &TimeStop, &Days, &Signals);

unsigned int Time;
unsigned char Day;
ParseTime(NearTimeStart, &Time, &Day);

DataArray[11] = getNumChar(Time % 10);
Time /= 10;
DataArray[10] = getNumChar(Time % 6);
Time /= 6;
DataArray[9] = ':';
DataArray[8] = getNumChar(Time % 10);
DataArray[7] = getNumChar(Time / 10);

for (unsigned char i = 1; i < 4; i++) {
unsigned char SignalOn = Signals % 2;
Signals /= 2;
if (SignalOn == 1) {
DataArray[13] = DataArray[14];
DataArray[14] = DataArray[15];
DataArray[15] = getNumChar(i);
}
}

unsigned char *DataArray2 = GetDayOfWeek(Day);
DataArray[2] = DataArray2[0];
DataArray[3] = DataArray2[1];

OutputString(DataArray, line, 0, 0);

if (flags.DetailModeOfViewSheduler) {
unsigned char DataArrayOfLine2[] = "    --:--";
int j2 = sizeof (DataArrayOfLine2) - 1;
DataArrayOfLine2[--j2] = getNumChar(TimeStop % 10);
TimeStop /= 10;
DataArrayOfLine2[--j2] = getNumChar(TimeStop % 6);
TimeStop /= 6;
j2--;
DataArrayOfLine2[--j2] = getNumChar(TimeStop % 10);
DataArrayOfLine2[--j2] = getNumChar(TimeStop / 10);

unsigned char CellsNumber = AdressOfNextStartCell / 8 + 1;
do {
char d = getNumChar(CellsNumber % 10);
DataArrayOfLine2[2] = DataArrayOfLine2[1];
DataArrayOfLine2[1] = d;
CellsNumber /= 10;
} while (CellsNumber > 0);

OutputString(DataArrayOfLine2, 1, 0, 0);
}
} else {
if (flags.DetailModeOfViewSheduler) {
clrInd();
flags.DetailModeOfViewSheduler = 0;
}
OutputString("                ", 1, 0, 0);
}
}

void EEWR(unsigned int adress, unsigned char data) {
volatile unsigned char INTCON_BUP = INTCON;
INTCONbits.GIEH = 0;
INTCONbits.GIEL = 0;
asm(" clrwdt");
EEADRH = adress >> 8;
EEADR = adress % 256;
EEDATA = data;
EECON1bits.EEPGD = 0;
EECON1bits.CFGS = 0;
EECON1bits.WREN = 1;
EECON2 = 0x55;
EECON2 = 0xAA;
EECON1bits.WR = 1;
EECON1bits.WREN = 0;
while (EECON1bits.WR == 1) {
}
PIR2bits.EEIF = 0;
INTCON = INTCON_BUP;
}

unsigned char EERD(unsigned int adress) {
volatile unsigned char INTCON_BUP = INTCON;
volatile unsigned char EEDATA_BUP;
INTCONbits.GIEH = 0;
INTCONbits.GIEL = 0;
asm(" clrwdt");
EEADRH = adress >> 8;
EEADR = adress % 256;
EECON1bits.EEPGD = 0;
EECON1bits.CFGS = 0;
EECON1bits.RD = 1;
EEDATA_BUP = EEDATA;
INTCON = INTCON_BUP;
return EEDATA_BUP;
}

void OutputInteractiveData(SymbolData *data[], unsigned char length, unsigned char start_symbol) {
for (unsigned char i = 0; i < length; i++) {
unsigned char s = start_symbol + (*(data[i])).index;
unsigned char line = s / 16;
if (line == 1) {
s -= 16;
}
setDigit(line, s, (*(data[i])).symbol);
setBlink(line, s, (*(data[i])).props.blink);
}
}

void ReIndTimeEdit(TimeEditData *TimeData) {
for (char i = 0; i < 10; i++) {
if ((*((*TimeData).Date[i])).props.const_symbol == 0) {
(*((*TimeData).Date[i])).symbol = getNumChar((*((*TimeData).Date[i])).number);
}
(*((*TimeData).Date[i])).index = i;
}
for (char i = 0; i < 5; i++) {
if ((*((*TimeData).Time[i])).props.const_symbol == 0) {
(*((*TimeData).Time[i])).symbol = getNumChar((*((*TimeData).Time[i])).number);
}
(*((*TimeData).Time[i])).index = i;
}
(*((*TimeData).WeekDay[0])).symbol = getNumChar((*((*TimeData).WeekDay[0])).number);
(*((*TimeData).WeekDay[0])).index = 0;

char n = 0;
OutputInteractiveData((*TimeData).Date, 10, n);
OutputInteractiveData((*TimeData).Time, 5, n + 4 + 16);
OutputString(GetDayOfWeek((*((*TimeData).WeekDay[0])).number), 1, n + 1, 0);


unsigned char *sources_of_time [] = {
"<\\>",
"RTC",
"GSM"
};
unsigned char value = (*TimeData).TimeSource;
if (value != 0 && value != 1 && value != 2) {
value = 0;
}
OutputString("Src:", 0, n + 12, 0);
OutputString(sources_of_time[value], 1, n + 12, 0);
}

void InteractiveData_BlinkOFF(SymbolData * InteractiveData[], unsigned char leght) {
for (char i = 0; i < leght; i++) {
(*(*(InteractiveData + i))).props.blink = 0;
}
}

void TimeData_BlinkOFF(TimeEditData * TimeData) {
InteractiveData_BlinkOFF((*TimeData).Date, 10);
InteractiveData_BlinkOFF((*TimeData).Time, 5);
InteractiveData_BlinkOFF((*TimeData).WeekDay, 1);
}

void TimeData_INIT(TimeEditData * TimeData) {
for (char i = 0; i < 10; i++) {
(*((*TimeData).Date[i])).props.blink = 0;
(*((*TimeData).Date[i])).props.const_symbol = 0;
}
for (char i = 0; i < 5; i++) {
(*((*TimeData).Time[i])).props.blink = 0;
(*((*TimeData).Time[i])).props.const_symbol = 0;
}
(*((*TimeData).WeekDay[0])).props.blink = 0;
(*((*TimeData).WeekDay[0])).props.const_symbol = 0;

(*((*TimeData).Time[2])).symbol = ':';
(*((*TimeData).Time[2])).props.const_symbol = 1;
(*((*TimeData).Date[5])).symbol = '/';
(*((*TimeData).Date[5])).props.const_symbol = 1;
(*((*TimeData).Date[2])).symbol = '/';
(*((*TimeData).Date[2])).props.const_symbol = 1;

(*TimeData).TimeSource = flags.TimeSource;
}

void TimeEdit() {

clrInd();

unsigned char time_is_changed = 0;

long int temp = Clock / 6000;
long int n = temp;

TimeEditData TimeData;
SymbolData _time[5];
SymbolData _weekday[1];
SymbolData _date[10];

for (unsigned char i = 0; i < 5; i++) {
TimeData.Time[i] = &(_time[i]);
}
for (unsigned char i = 0; i < 1; i++) {
TimeData.WeekDay[i] = &(_weekday[i]);
}
for (unsigned char i = 0; i < 10; i++) {
TimeData.Date[i] = &(_date[i]);
}

TimeData_INIT(&TimeData);


(*(TimeData.Time[4])).number = temp % 10;
temp /= 10;
(*(TimeData.Time[3])).number = temp % 6;

temp /= 6;
temp %= 24;

(*(TimeData.Time[1])).number = temp % 10;
(*(TimeData.Time[0])).number = temp / 10;

(*(TimeData.WeekDay[0])).number = 1 + n / 1440;

(*(TimeData.Date[9])).number = cYears % 10;
(*(TimeData.Date[8])).number = cYears / 10;
(*(TimeData.Date[7])).symbol = '0';
(*(TimeData.Date[7])).props.const_symbol = 1;
(*(TimeData.Date[6])).symbol = '2';
(*(TimeData.Date[6])).props.const_symbol = 1;

(*(TimeData.Date[4])).number = cMonths % 10;
(*(TimeData.Date[3])).number = cMonths / 10;

(*(TimeData.Date[1])).number = cDays % 10;
(*(TimeData.Date[0])).number = cDays / 10;


SymbolData * symb_array [10];
unsigned char symb_array_max_index = 9;
unsigned char p = 0;
symb_array[p++] = TimeData.Date[0];
symb_array[p++] = TimeData.Date[1];
symb_array[p++] = TimeData.Date[3];
symb_array[p++] = TimeData.Date[4];
symb_array[p++] = TimeData.Date[8];
symb_array[p++] = TimeData.Date[9];

symb_array[p++] = TimeData.Time[0];
symb_array[p++] = TimeData.Time[1];
symb_array[p++] = TimeData.Time[3];
symb_array[p++] = TimeData.Time[4];

char blinking = 6;
char input = 255;
while (1) {
(*symb_array[blinking]).props.blink = 1;

(*(TimeData.WeekDay[0])).number = GetDayOfWeekByDate(
(*(TimeData.Date[8])).number * 10 + (*(TimeData.Date[9])).number,
(*(TimeData.Date[3])).number * 10 + (*(TimeData.Date[4])).number,
(*(TimeData.Date[0])).number * 10 + (*(TimeData.Date[1])).number
);

ReIndTimeEdit(&TimeData);

input = entNum(0, 9);

if (input != 255) {
(*symb_array[blinking]).number = input;
TimeData_BlinkOFF(&TimeData);
blinking == symb_array_max_index ? blinking = 0 : blinking++;
time_is_changed = 1;
}

if (KeyCode == 40) {
KeyCode = 0;
TimeData_BlinkOFF(&TimeData);
blinking == symb_array_max_index ? blinking = 0 : blinking++;
} else if (KeyCode == 44) {
KeyCode = 0;
if (TimeData.TimeSource != 0 && TimeData.TimeSource != 1) {
TimeData.TimeSource = 0;
} else {
TimeData.TimeSource++;
}
} else if (KeyCode == 41) {
KeyCode = 0;
TimeData_BlinkOFF(&TimeData);
blinking == 0 ? blinking = symb_array_max_index : blinking--;
} else if (KeyCode == 42) {
KeyCode = 0;
unsigned char t = 0;
if (time_is_changed) {
do {
t = (*symb_array[2]).number * 10 + (*symb_array[3]).number;
if (t > 12) {
TimeData_BlinkOFF(&TimeData);
blinking = 2;
break;
}

unsigned char month = t;

unsigned char MonthDays [] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
t = (*symb_array[4]).number * 10 + (*symb_array[5]).number;
if (t % 4 == 0) {
MonthDays[1] = 29;
}
t = (*symb_array[0]).number * 10 + (*symb_array[1]).number;
if (MonthDays[month - 1] < t) {
(*symb_array[0]).number = MonthDays[month - 1] / 10;
(*symb_array[1]).number = MonthDays[month - 1] % 10;
TimeData_BlinkOFF(&TimeData);
blinking = 0;
break;
}

t = (*symb_array[6]).number * 10 + (*symb_array[7]).number;
if (t > 23) {
TimeData_BlinkOFF(&TimeData);
blinking = 7;
break;
}

t = (*symb_array[8]).number * 10 + (*symb_array[9]).number;
if (t > 59) {
TimeData_BlinkOFF(&TimeData);
blinking = 9;
break;
}

t = 0;

Clock = ((long int) ((*(TimeData.WeekDay[0])).number - 1) * 86400
+ (long int) ((*symb_array[6]).number * 10 + (*symb_array[7]).number) * 3600
+ (long int) ((*symb_array[8]).number * 10 + (*symb_array[9]).number) * 60) * 100;

cDays = (*symb_array[0]).number * 10 + (*symb_array[1]).number;
cMonths = (*symb_array[2]).number * 10 + (*symb_array[3]).number;
cYears = (*symb_array[4]).number * 10 + (*symb_array[5]).number;

if (TimeData.TimeSource != flags.TimeSource) {
SetTimeSource(TimeData.TimeSource);
}

WriteTime(Clock, cDays, cMonths, cYears);

} while (0);

}

if (t == 0) {
if (!time_is_changed && TimeData.TimeSource != flags.TimeSource) {
SetTimeSource(TimeData.TimeSource);
}
clrInd();
break;
}
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
break;
}
}
}

unsigned long int ReadFourBytesEE(unsigned int adress) {
unsigned long int x;
for (int i = 3; i >= 0; i--) {
x = x * 256 + EERD(adress + i);
}
return x;
}

void FillArrayFromEEPROM(unsigned char *container, unsigned int adress_start, unsigned int quantity) {
for (unsigned char i = 0; i < quantity; i++) {
container[i] = EERD(adress_start + i);
}
}

void FillPhonebookCellFromEEPROM(Phone *container, unsigned int adress_start) {
FillArrayFromEEPROM((*container).name, adress_start, sizeof ((*container).name));
adress_start += sizeof ((*container).name);
FillArrayFromEEPROM((*container).phone, adress_start, sizeof ((*container).phone));
adress_start += sizeof ((*container).phone);
FillArrayFromEEPROM((*container).blocked, adress_start, sizeof ((*container).blocked));
adress_start += sizeof ((*container).blocked);
FillArrayFromEEPROM((*container).filled, adress_start, sizeof ((*container).filled));
}

void FillArrayFromEEPROM_interr(unsigned char * container, unsigned int adress_start, unsigned int quantity) {
for (unsigned char i = 0; i < quantity; i++) {
container[i] = EERD(adress_start + i);
}
}

void WriteFourBytesEE(unsigned int adress, unsigned long int data) {
for (int i = 0; i < 4; i++) {
EEWR(adress + i, data % 256);
data /= 256;
}
}

void WriteArrayToEEPROM(unsigned char * container, unsigned int adress_start, unsigned int quantity) {
for (unsigned char i = 0; i < quantity; i++) {
EEWR(adress_start + i, container[i]);
}
}

void WritePhonebookCellToEEPROM(Phone *container, unsigned int adress_start) {
WriteArrayToEEPROM((*container).name, adress_start, sizeof ((*container).name));
adress_start += sizeof ((*container).name);
WriteArrayToEEPROM((*container).phone, adress_start, sizeof ((*container).phone));
adress_start += sizeof ((*container).phone);
WriteArrayToEEPROM((*container).blocked, adress_start, sizeof ((*container).blocked));
adress_start += sizeof ((*container).blocked);
WriteArrayToEEPROM((*container).filled, adress_start, sizeof ((*container).filled));
}

void delay(unsigned char del, unsigned int count) {
while (count > 0) {
TMR2 = 0;
PR2 = del;
TMR2IF = 0;
while (!TMR2IF);
count--;
};
return;
}

void SendSymbolToLCD(unsigned char Symb) {
unsigned char Smb = 0;
for (int a = 8; a > 0; a--) {
Smb *= 2;
if (Symb % 2 == 1) {
Smb++;
}
Symb /= 2;

}

LC1 = 1;
LATA = (0b11110000 & (Smb * 16)) / 4 | ((flags.LCD_Light_On == 1 || flags.ActiveCall == 1 && flags.IncommingCall == 1) ? 0b00000010 : 0b00000000);
LC0 = 1;

delay(10, 1);
LC0 = 0;
LC1 = 0;

delay(25, 5);

LC1 = 1;
LATA = (0b11110000 & Smb) / 4 | ((flags.LCD_Light_On == 1 || flags.ActiveCall == 1 && flags.IncommingCall == 1) ? 0b00000010 : 0b00000000);
LC0 = 1;

delay(10, 1);
LC0 = 0;
LC1 = 0;

delay(25, 5);
}

void SendArrayToLCD(unsigned char *Symb, char line, char position) {
unsigned int i = 0;
while (Symb[i] != 255 && position < 17) {
setDigit(line, position, Symb[i]);
i++;
position++;
}
}

void lcd_send_initial_half_byte(unsigned char data) {
LC1 = 0;
unsigned char data_temp = 0;

for (int a = 4; a > 0; a--) {
data_temp *= 2;
if (data % 2 == 1) {
data_temp++;
}
data /= 2;

}
LATA = (0b00111100 & (data_temp * 4)) | ((flags.LCD_Light_On == 1 || flags.ActiveCall == 1 && flags.IncommingCall == 1) ? 0b00000010 : 0b00000000);
LC0 = 1;
LC0 = 0;
}

void lcd_send_byte(unsigned char data) {
lcd_send_initial_half_byte((data & 0b11110000) / 16);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_initial_half_byte(data & 0b00001111);
_delay((unsigned long)((40)*(40000000/4000000.0)));
}

void lcd_off() {
flags.LCD_Light_On = 0;
lcd_send_byte(0b00001000);
flags.LCD_Power_On = 0;
LC2 = 0;
}

void lcd_on() {
LC2 = 1;
lcd_init();
lcd_send_byte(0b00001100);
flags.LCD_Power_On = 1;
}

void lcd_init() {
unsigned char INTCON_BUF = INTCON;
INTCONbits.GIEH = 0;
INTCONbits.GIEL = 0;
LC0 = 0;
LC1 = 0;

_delay((unsigned long)((10)*(40000000/4000.0)));
_delay((unsigned long)((10)*(40000000/4000.0)));
lcd_send_initial_half_byte(0b00000011);
_delay((unsigned long)((5)*(40000000/4000.0)));
lcd_send_initial_half_byte(0b00000011);
_delay((unsigned long)((110)*(40000000/4000000.0)));
lcd_send_initial_half_byte(0b00000011);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_initial_half_byte(0b00000010);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_byte(0b00101100);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_byte(0b00001000);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_byte(0b00000001);
_delay((unsigned long)((40)*(40000000/4000000.0)));
lcd_send_byte(0b00010010);
_delay((unsigned long)((40)*(40000000/4000000.0)));


LC0 = 0;
LC1 = 0;

lcd_send_byte(0b00000001);
_delay((unsigned long)((2)*(40000000/4000.0)));

INTCON = (INTCON_BUF | 0b11000000) | (INTCON & 0b00111111);
}

unsigned char TestKeyGroup() {
if (PORTBbits.RB6 == 0) {
return 1;
} else if (PORTBbits.RB4 == 0) {
return 2;
} else if (PORTBbits.RB2 == 0) {
return 3;
} else if (PORTBbits.RB0 == 0) {
return 4;
} else {
return 17;
}
}

unsigned char ConvKeyNum(unsigned char Num) {
switch (Num) {
case 0: return 39;
case 1: return 43;
case 2: return 42;
case 3: return 41;
case 4: return 40;
case 5: return 45;
case 6: return 33;
case 7: return 36;
case 8: return 31;
case 9: return 32;
case 10: return 35;
case 11: return 34;
case 12: return 38;
case 13: return 30;
case 14: return 44;
case 15: return 37;
default: return 0;
}
}

unsigned int FindCell(unsigned int adressStart, char New, unsigned int previous) {

if (adressStart == (8 * 48)) {
adressStart = ((8 * 48) - 8);
}
unsigned int adress = adressStart;
unsigned int adressNew = (8 * 48);
do {

if (!previous) {
adress == ((8 * 48) - 8) ? adress = 0 : adress += 8;
} else {
adress == 0 ? adress = ((8 * 48) - 8) : adress -= 8;
}

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, adress);
unsigned char CellIsEmpty = 1;
for (unsigned char i = 0; i < 8; i++) {
if (CellsData[i] != 0xFF) {
CellIsEmpty = 0;
}
}

if (New != 1 ? CellIsEmpty == 0 : CellIsEmpty == 1) {
adressNew = adress;
break;
}
} while (adress != adressStart);
return adressNew;
}

unsigned int RefreshSchedulerIndicator(unsigned int adress, char New, unsigned int CopyFrom) {

unsigned int cell = 0;

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, adress);
unsigned char CellIsEmpty = 1;
for (unsigned char i = 0; i < 8; i++) {
if (CellsData[i] != 0xFF) {
CellIsEmpty = 0;
}
}

if (adress != (8 * 48) && (New != 1 ? CellIsEmpty == 0 : CellIsEmpty == 1)) {
cell = adress / 8 + 1;
} else {
adress = FindCell(adress, New, 0);
if (adress != (8 * 48)) {
cell = adress / 8 + 1;
}
}

if (cell != 0) {
unsigned char num [] = "  ";
NumericToString(cell, num, sizeof (num));
OutputString(num, 0, 14, 0);
} else {
OutputString("--", 0, 14, 0);
}

if (New == 1) {
if (CopyFrom != (8 * 48)) {
OutputString(" ", 1, 0, 0);
unsigned char num [] = "  ";
NumericToString(1 + CopyFrom / 8, num, sizeof (num));
OutputString(num, 1, 14, 0);
}
OutputString(" ", 0, 0, 0);
}
OutputString(" ", 0, 6, 0);

return adress;
}

void ItemsToIndicator(unsigned char items, unsigned char max_i, unsigned char firstDigit) {
for (char i = 1; i < max_i; i++) {
items % 2 == 1 ? setDigit(0, 16 - (firstDigit - i), getNumChar(i)) : setDigit(0, 16 - (firstDigit - i), '-');
items /= 2;
}
}

unsigned char getBorderUp(char n) {
unsigned char BorderUp;
switch (n) {
case 11: case 5: BorderUp = 2;
break;
case 10: case 4: getDigit(0, n + 1) == 2 ? BorderUp = 3: BorderUp = 9;
break;
case 8: case 2: BorderUp = 5;
break;
case 7: case 1: BorderUp = 9;
break;
}
return BorderUp;
}

unsigned char ConvertDayToBit(unsigned char DayNumber) {
switch (DayNumber) {
case 1: return 0b00000001;
case 2: return 0b00000010;
case 3: return 0b00000100;
case 4: return 0b00001000;
case 5: return 0b00010000;
case 6: return 0b00100000;
case 7: return 0b01000000;
default: return 0;
}
}

void ReadDataOfCell(unsigned char *CellsData, unsigned long int *Data, unsigned int TargetAdress) {
FillArrayFromEEPROM(CellsData, TargetAdress, 8);
for (int i = 3; i >= 0; i--) {
*Data = *Data * 256 + CellsData[i];
}
}

void ReadDataOfCell_interr(unsigned char *CellsData, unsigned long int *Data, unsigned int TargetAdress) {
FillArrayFromEEPROM_interr(CellsData, TargetAdress, 8);
for (int i = 3; i >= 0; i--) {
*Data = *Data * 256 + CellsData[i];
}
}

void WriteDataOfCell(unsigned char *CellsData, unsigned long int *Data, unsigned int TargetAdress) {
for (unsigned char i = 0; i < 4; i++) {
CellsData[i] = (unsigned char) (*Data % 256);
*Data /= 256;
}
WriteArrayToEEPROM(CellsData, TargetAdress, 8);
}

void CleanStringArray(unsigned char *myArray, unsigned int size, unsigned char settingData) {
for (unsigned int i = 0; i < size; i++) {
*(myArray + i) = settingData;
}
}

void _CleanStringArray_interrupt(unsigned char *myArray, unsigned int size, unsigned char settingData) {
for (unsigned int i = 0; i < size; i++) {
*(myArray + i) = settingData;
}
}

void _CleanStringArray_interrupt2(unsigned char *myArray, unsigned int size, unsigned char settingData) {
for (unsigned int i = 0; i < size; i++) {
*(myArray + i) = settingData;
}
}

void DeleteDataOfCell(unsigned int TargetAdress) {
unsigned char CellsData [8];
CleanStringArray(CellsData, sizeof (CellsData), 0xFF);
WriteArrayToEEPROM(CellsData, TargetAdress, 8);
}

unsigned char EditSchedule(unsigned int adress, unsigned int SourceOfRecord) {

unsigned int TargetAdress;
if (SourceOfRecord == (8 * 48)) {
TargetAdress = adress;
} else {
TargetAdress = SourceOfRecord;
}

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, TargetAdress);

char BeginEditTimes = 0;
if (Data == 0xFFFFFFFF) {
Data = 0;
BeginEditTimes = 1;
}

unsigned int TimeStart;
unsigned int TimeStop;
unsigned char Days;
unsigned char Signals;
ParseDataRecord(Data, &TimeStart, &TimeStop, &Days, &Signals);

clrInd();

char mode = 1;
unsigned char key;

SymbolData * TimesOutput[11];
SymbolData _times[11];
for (unsigned char i = 0; i < 11; i++) {
_times[i].index = i;
_times[i].number = 0;
_times[i].symbol = '0';
_times[i].props.blink = 0;
_times[i].props.const_symbol = 0;
TimesOutput[i] = &(_times[i]);
}

_times[2].symbol = ':';
_times[2].props.const_symbol = 1;
_times[5].symbol = '-';
_times[5].props.const_symbol = 1;
_times[8].symbol = ':';
_times[8].props.const_symbol = 1;

SymbolData * Times[8];
unsigned char i = 0;
Times[i++] = &(_times[0]);
Times[i++] = &(_times[1]);
Times[i++] = &(_times[3]);
Times[i++] = &(_times[4]);
Times[i++] = &(_times[6]);
Times[i++] = &(_times[7]);
Times[i++] = &(_times[9]);
Times[i++] = &(_times[10]);


while (1) {
if (KeyCode == 43) {
KeyCode = 0;
clrInd();
return 0;
} else if (KeyCode == 42) {
KeyCode = 0;
Data = (unsigned long int) Signals * 0x20000000 + (unsigned long int) Days * 0x400000 + (unsigned long int) TimeStop * 0x800 + (unsigned long int) TimeStart;
WriteDataOfCell(&CellsData, &Data, adress);
clrInd();
return 1;
}

switch (mode) {
case 1:
{
unsigned int temp;

temp = TimeStop;
_times[10].number = temp % 10;
temp /= 10;
_times[9].number = temp % 6;
temp = temp / 6;
_times[7].number = temp % 10;
_times[6].number = temp / 10;

temp = TimeStart;
_times[4].number = temp % 10;
temp /= 10;
_times[3].number = temp % 6;
temp = temp / 6;
_times[1].number = temp % 10;
_times[0].number = temp / 10;

for (char i = 0; i < 8; i++) {
(*(Times[i])).symbol = getNumChar((*(Times[i])).number);
}
OutputInteractiveData(TimesOutput, 11, 5);

if (KeyCode == 45 || BeginEditTimes == 1) {
KeyCode = 0;
BeginEditTimes = 0;
unsigned char blinking = 0;

while (1) {

InteractiveData_BlinkOFF(Times, 8);
(*(Times[blinking])).props.blink = 1;
for (char i = 0; i < 8; i++) {
(*(Times[i])).symbol = getNumChar((*(Times[i])).number);
}
OutputInteractiveData(TimesOutput, 11, 5);

if (KeyCode == 43) {
KeyCode = 0;
clrInd();
break;
} else if (KeyCode == 42) {
KeyCode = 0;

unsigned int T[2];
unsigned char OK = 1;
for (char j = 0; j < 2 && OK; j++) {
char f = j * 4;
unsigned char HH = (*(Times[f + 0])).number;
unsigned char HL = (*(Times[f + 1])).number;
unsigned char MH = (*(Times[f + 2])).number;
unsigned char ML = (*(Times[f + 3])).number;

if (HH * 10 + HL > 23) {
blinking = 0 + f;
OK = 0;
continue;
}

if (MH * 10 + ML > 59) {
blinking = 2 + f;
OK = 0;
continue;
}

T[j] = HH * 600 + HL * 60 + MH * 10 + ML;
}
if (OK) {
if (T[0] > T[1]) {
for (char j = 0; j < 4; j++) {
(*(Times[j + 4])).number = (*(Times[j])).number;
}
blinking = 4;
OK = 0;
}
}
if (OK) {
InteractiveData_BlinkOFF(Times, 8);
TimeStart = T[0];
TimeStop = T[1];
break;
}
} else if (KeyCode == 40) {
KeyCode = 0;
if (blinking < 7) {
blinking++;
}
} else if (KeyCode == 41) {
KeyCode = 0;
if (blinking > 0) {
blinking--;
}
}

key = entNum(0, 9);
if (key != 255) {
(*(Times[blinking])).number = key;
if (blinking < 7) {
blinking++;
}
}
}
}
}
break;
case 2:
{
ItemsToIndicator(Days, 8, 9);
key = entNum(1, 7);
if (key != 255) {
Days ^= ConvertDayToBit(key);
} else if (KeyCode == 30) {
KeyCode = 0;
Days = 0;
} else if (KeyCode == 45) {
KeyCode = 0;
Days = 0b01111111;
}
}
break;
case 3:
{
ItemsToIndicator(Signals, 4, 8);
key = entNum(1, 3);
if (key != 255) {
Signals ^= ConvertDayToBit(key);
} else if (KeyCode == 30) {
KeyCode = 0;
Signals = 0;
} else if (KeyCode == 45) {
KeyCode = 0;
Signals = 0b00000111;
}
}
}
if (KeyCode == 40) {
KeyCode = 0;
clrInd();
if (mode == 3) {
mode = 1;
} else {
mode++;
}
} else if (KeyCode == 41) {
KeyCode = 0;
clrInd();
if (mode == 1) {
mode = 3;
} else {
mode--;
}
}
}
return 0;
}

void ShowSchedulerMenu(unsigned int NumberOfCells) {
clrInd();

unsigned char *menu[] = {
"",
"",
"",
"",
" ",
(0)
};
unsigned char item = ShowMenu(menu, 0);

if (item == 1) {
SchedulerNew((8 * 48));
} else if (NumberOfCells != (8 * 48) && item == 2) {
EditSchedule(NumberOfCells, (8 * 48));
} else if (NumberOfCells != (8 * 48) && item == 3) {
SchedulerNew(NumberOfCells);
} else if (NumberOfCells != (8 * 48) && item == 4) {
DeleteDataOfCell(NumberOfCells);
} else if (item == 5) {
if (Select_OK_NO("  ?")) {
OutputSystemMessage("  ...");
Format_EEPROM_Memory(0, (8 * 48) - 1, 0);
OutputSystemMessage("!");
}
}
}

void Scheduler(unsigned int StartFrom) {
clrInd();
volatile static unsigned int NumberOfCells = 0;
if (StartFrom != (8 * 48)) {
NumberOfCells = StartFrom;
}

while (1) {
NumberOfCells = RefreshSchedulerIndicator(NumberOfCells, 0, (8 * 48));

if (KeyCode == 45) {
KeyCode = 0;
ShowSchedulerMenu(NumberOfCells);
} else if (KeyCode == 40) {
KeyCode = 0;
NumberOfCells = FindCell(NumberOfCells, 0, 0);
} else if (KeyCode == 41) {
KeyCode = 0;
NumberOfCells = FindCell(NumberOfCells, 0, 1);
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
return;
} else if (KeyCode == 30) {
KeyCode = 0;
NumberOfCells = 0;
}
}
}

void SchedulerNew(unsigned int SourceOfRecord) {
clrInd();
volatile static unsigned int NumberOfCells = 0;
while (1) {
NumberOfCells = RefreshSchedulerIndicator(NumberOfCells, 1, SourceOfRecord);
if (NumberOfCells != (8 * 48) && KeyCode == 45) {
KeyCode = 0;
if (EditSchedule(NumberOfCells, SourceOfRecord) == 1) {
NumberOfCells = FindCell(NumberOfCells, 1, 0);
}
} else if (KeyCode == 40) {
KeyCode = 0;
NumberOfCells = FindCell(NumberOfCells, 1, 0);
} else if (KeyCode == 41) {
KeyCode = 0;
NumberOfCells = FindCell(NumberOfCells, 1, 1);
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
return;
} else if (KeyCode == 30) {
KeyCode = 0;
NumberOfCells = 0;
}
}
}

void ParseTime(long int TimeValue, unsigned int *Time, unsigned char *Day) {
unsigned int DayTime = (unsigned int) (TimeValue / 6000);
*Time = DayTime % 1440;
*Day = DayTime / 1440 + 1;
}

void ParseDataRecord(unsigned long int Data, unsigned int *TimeStart, unsigned int *TimeStop, unsigned char *Days, unsigned char *Signals) {

*TimeStart = (unsigned int) (Data % (unsigned long int) 2048);
Data /= 2048;
*TimeStop = (unsigned int) (Data % (unsigned long int) 2048);
Data /= 2048;
*Days = (unsigned char) (Data % (unsigned long int) 128);
Data /= 128;
*Signals = (unsigned char) (Data % (unsigned long int) 8);

}

unsigned int FindNextTimeStart(unsigned long int *TimeFrom) {

unsigned int adress = 0;
unsigned int adressStart = (8 * 48);
unsigned char TimeIsFound = 0;
unsigned long int LastFoundTimeStart;

do {
unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, adress);

adress += 8;
if (Data == 0xFFFFFFFF) {
continue;
}
unsigned int TimeStart;
unsigned int TimeStop;
unsigned char Days;
unsigned char Signals;
ParseDataRecord(Data, &TimeStart, &TimeStop, &Days, &Signals);

if (Signals == 0) {
continue;
}
for (char DayIndex = 0; DayIndex < 7; DayIndex++) {
unsigned char DayOn = Days % 2;
Days /= 2;
if (DayOn != 1) {
continue;
}
unsigned long int TimeOfSignals = ((unsigned long int) DayIndex * 86400 + (unsigned long int) TimeStart * 60) * 100;

if ((TimeOfSignals < LastFoundTimeStart || TimeIsFound == 0) && TimeOfSignals > *TimeFrom) {
TimeIsFound = 1;
LastFoundTimeStart = TimeOfSignals;
adressStart = adress - 8;
}
}
} while (adress < (8 * 48));

if (TimeIsFound == 1) {
*TimeFrom = LastFoundTimeStart;
} else {
*TimeFrom = 0;
}
return adressStart;
}

void Format_EEPROM_Memory(unsigned int first_cell, unsigned int last_cell, unsigned char interactive) {
if (interactive != 1 || Select_OK_NO(" ?") && Select_OK_NO(" ! ?")) {
if (interactive == 1) {
OutputSystemMessage("  ...");
}
for (unsigned int i = first_cell; i < last_cell - 1; i++) {
EEWR(i, 0xFF);
}
if (interactive == 1) {
OutputSystemMessage("!");
}
}
}

void SignalsOnOff() {
if (!flags.LockSignals && CurrentReadingCell < (8 * 48)) {

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell_interr(&CellsData, &Data, CurrentReadingCell);

if (Data != 0xFFFFFFFF) {
unsigned int TimeStart;
unsigned int TimeStop;
unsigned char Days;
unsigned char Signals;
TimeStart = Data % 2048;
Data /= 2048;
TimeStop = Data % 2048;
Data /= 2048;
Days = Data % 128;
Data /= 128;
Signals = Data % 8;
if (Signals != 0 && Days != 0) {
unsigned int ThisTime;
unsigned char ThisDay;
unsigned int DayTime = (unsigned int) (Clock / 6000);
ThisTime = DayTime % 1440;
ThisDay = DayTime / 1440 + 1;
ThisDay = ConvertDayToBit(ThisDay);
if (((ThisDay & Days) > 0) && (TimeStart <= ThisTime) && (TimeStop >= ThisTime)) {
SignalsOut = Signals | SignalsOut;
}
}
}
CurrentReadingCell += 8;
} else {
SignalsForInd = (flags.LockSignals ? 0 : SignalsOut);
SignalsOut = 0;
CurrentReadingCell = 0;
unsigned char Data = (PORTB & 0b00011111) | ((CurrentSignals | SignalsForInd)*32);
if ((Data & 0b11100000) != CurrentSignalsData) {
EEWR(1014, cMinutes);
EEWR(1015, cHours);
EEWR(1016, cWeekDay);
EEWR(1017, cDays);
EEWR(1018, cMonths);
EEWR(1019, cYears);
flags.SignalsAreChanged = 1;
}
CurrentSignalsData = Data & 0b11100000;
PORTB = Data;
}
}

void FillMinutes() {
Minutes = Clock - 3000;
}

Phone *FindPhoneContactByNumber(unsigned char *number) {
Phone container;

unsigned char found = 0;

for (unsigned char i = 0; i < 16; i++) {
FillPhonebookCellFromEEPROM(&container, ((8 * 48)) + sizeof (container) * i);
if (container.filled[0] != 1) {
continue;
}

unsigned char end_of_phone = 0;
while (container.phone[end_of_phone + 1] != '\0') {
end_of_phone++;
}

for (unsigned char j = 0; j < 10 && (end_of_phone - j + 1) > 0; j++) {
if (container.phone[end_of_phone - j] != *(number + 9 - j)) {
found = 0;
break;
} else {
found = 1;
}
}

if (found) {
break;
}
}

if (found) {
return &container;
} else {
return (0);
}
}

unsigned char *_getContainer_Clock_from_GSM() {
CleanStringArray(Clock_from_GSM, sizeof (Clock_from_GSM), '\0');
return Clock_from_GSM;
}

unsigned char *_getContainer_Incomming_Call_Data() {
CleanStringArray(Incomming_Call_Data, sizeof (Incomming_Call_Data), '\0');
return Incomming_Call_Data;
}

unsigned char *_getContainer_Incomming_DTMF_Data() {
CleanStringArray(Incomming_DTMF_Data, sizeof (Incomming_DTMF_Data), '\0');
return Incomming_DTMF_Data;
}

unsigned char GetDayOfWeekByDate(unsigned char _year, unsigned char _mounth, unsigned char _day) {
const unsigned char century_number = 20;
if (_mounth < 3) {
_mounth += 12;
_year--;
}
return ((_day + 13 * (_mounth + 1) / 5 + _year + _year / 4 - 2 * (century_number % 4)) + 5) % 7 + 1;
}

unsigned char GetNumericFromString(unsigned char *string, unsigned char index) {
return ConvertCharToNumeric(*(string + index));
}

void ProcessIncommingUartData() {

if (flags.UnprocessedIncommingUartData) {
flags.UnprocessedIncommingUartData = 0;

if (!flags.UsartExchangeEnabled) {
return;
}

flags.IsUartOK = 0;

if (_FindIncommingData_interrupt(StandardAnswer_OK, (0), (3 - 1))) {
flags.IsUartOK = 1;
} else if (_FindIncommingData_interrupt("RING", (0), (3 - 1))) {

} else if (_FindIncommingData_interrupt(StandardAnswer_CLOCK, _getContainer_Clock_from_GSM(), (3 - 1))) {



cYears = GetNumericFromString(Clock_from_GSM, 8) * 10 + GetNumericFromString(Clock_from_GSM, 9);
cMonths = GetNumericFromString(Clock_from_GSM, 11) * 10 + GetNumericFromString(Clock_from_GSM, 12);
cDays = GetNumericFromString(Clock_from_GSM, 14) * 10 + GetNumericFromString(Clock_from_GSM, 15);
long int tClock = ((long int) (GetDayOfWeekByDate(cYears, cMonths, cDays) - 1) * 86400
+ (long int) (GetNumericFromString(Clock_from_GSM, 17) * 10 + GetNumericFromString(Clock_from_GSM, 18)) * 3600
+ (long int) (GetNumericFromString(Clock_from_GSM, 20) * 10 + GetNumericFromString(Clock_from_GSM, 21)) * 60
+ (long int) (GetNumericFromString(Clock_from_GSM, 23) * 10 + GetNumericFromString(Clock_from_GSM, 24))) * 100;

CalculateClockDelta(tClock);
Clock = tClock;

} else if (_FindIncommingData_interrupt(StandardAnswer_INCCALL, _getContainer_Incomming_Call_Data(), (3 - 1))) {
unsigned char number [11];
_CleanStringArray_interrupt(number, sizeof (number), '\0');

for (unsigned char i = 0; i < sizeof (number) - 1; i++) {
number[i] = Incomming_Call_Data[i + 11];
}
Phone *contact = FindPhoneContactByNumber(number);
if (contact == (0)) {
SendCommandToUSART("ATH0", 0);
flags.ActiveCall = 0;

unsigned char msg [33];
_CleanStringArray_interrupt(msg, sizeof (msg), '\0');
strcat(msg, "        ");
strcat(msg, number);
OutputSystemMessage(msg);
} else {
SendCommandToUSART("ATA", 1);
while (!_FindIncommingData_interrupt(StandardAnswer_OK, (0), (3 - 1)));
flags.ActiveCall = 1;
flags.IncommingCall = 1;
strcpy(active_phone, (*contact).phone);
SendCommandToUSART("AT+DDET=1", 1);
flags.RemoteControlIsEnabled = 0;
}

if (flags.LCD_Power_On == 0) {
lcd_on();
}
} else if (_FindIncommingData_interrupt(StandardAnswer_DTMF, _getContainer_Incomming_DTMF_Data(), (3 - 1))) {

DTMF_Symbol = Incomming_DTMF_Data[sizeof (Incomming_DTMF_Data) - 2];
if (flags.RemoteControlIsEnabled) {
unsigned char answerString [] = "AT+VTS=\" \"";
answerString[8] = DTMF_Symbol;
_CleanStringArray_interrupt(IncommingBuffer[(3 - 1)], 256, '\0');
SendCommandToUSART(answerString, 1);
while (!_FindIncommingData_interrupt(StandardAnswer_OK, (0), (3 - 1)));

if (DTMF_Symbol == '4') {
CurrentSignals = 0;
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '6') {
CurrentSignals &= 0b00000010;
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '1') {
CurrentSignals = CurrentSignals | 0b00000001;
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '2') {
CurrentSignals = CurrentSignals | 0b00000010;
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '3') {
CurrentSignals = CurrentSignals | 0b00000100;
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '0') {
flags.LockSignals = 1;
CurrentSignals = 0;
EEWR(1020, flags.LockSignals);
flags.SignalsAreChanged = 1;
} else if (DTMF_Symbol == '5') {
flags.LockSignals = 0;
flags.SignalsAreChanged = 1;
EEWR(1020, flags.LockSignals);
} else if (DTMF_Symbol == '#') {
flags.StatusIsRequested = 1;
flags.ActiveCall = 0;
_CleanStringArray_interrupt(IncommingBuffer[(3 - 1)], 256, '\0');
SendCommandToUSART("ATH0", 1);
while (!_FindIncommingData_interrupt(StandardAnswer_OK, (0), (3 - 1)));
flags.RemoteControlIsEnabled = 0;
}
} else if (DTMF_Symbol == '*') {
flags.RemoteControlIsEnabled = 1;
}

} else if (_FindIncommingData_interrupt(StandardAnswer_NO_CARRIER, (0), (3 - 1))) {
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;

} else if (_FindIncommingData_interrupt(StandardAnswer_BUSY, (0), (3 - 1))) {
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;

} else if (_FindIncommingData_interrupt(StandardAnswer_NO_ANSWER, (0), (3 - 1))) {
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;

} else if (_FindIncommingData_interrupt(StandardAnswer_NO_DIALTONE, (0), (3 - 1))) {
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;

} else if (_FindIncommingData_interrupt(StandardAnswer_ERROR, (0), (3 - 1))) {
OutputSystemMessage(" GSM");

} else if (_FindIncommingData_interrupt(StandardAnswer_NORMAL_POWER_DOWN, (0), (3 - 1))) {
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;
flags.GSM_Connected = 0;
}

}
}

void AddByteToUSARTbuff(unsigned char byte) {

static struct {
unsigned is_r : 1;
unsigned is_n : 1;
unsigned is_rn : 1;
} lastdata;

if (byte == '\r') {
if (!lastdata.is_rn) {
lastdata.is_r = 1;
}
} else if (byte == '\n' && lastdata.is_r) {
if (!lastdata.is_rn) {
lastdata.is_n = 1;
}
} else {
if (lastdata.is_r || lastdata.is_n) {
lastdata.is_r = 0;
lastdata.is_n = 0;
}
if (byte != '\n') {
lastdata.is_rn = 0;
for (unsigned int i = 0; i < 256 - 2; i++) {
*(*(IncommingBuffer + 3) + i) = *(*(IncommingBuffer + 3) + i + 1);
}
*(*(IncommingBuffer + 3) + 256 - 2) = byte;
}
}

if (lastdata.is_r && lastdata.is_n) {
lastdata.is_r = 0;
lastdata.is_n = 0;

lastdata.is_rn = 1;

unsigned char *buff = IncommingBuffer[0];
for (unsigned char i = 0; i < 3; i++) {
IncommingBuffer[i] = IncommingBuffer[i + 1];
}
IncommingBuffer[3] = buff;
_CleanStringArray_interrupt2(IncommingBuffer[3], 256, '\0');

flags.UnprocessedIncommingUartData = 1;
}
}

void _load_TXREG() {
if (OutcommingBuffer == (0) && TXSTAbits.TRMT) {
TXSTAbits.TXEN = 0;
return;
}
if ((*OutcommingBuffer) == '\0') {
while (!TXSTAbits.TRMT);
TXREG = 0x0D;
TXREG = 0x0A;
OutcommingBuffer = (0);
} else if (OutcommingBuffer != (0)) {
TXREG = *OutcommingBuffer++;
}
}

void interrupt high_priority F_h() {

if (PIR1bits.RCIF == 1) {
AddByteToUSARTbuff(RCREG);
} else if (PIR1bits.TXIF == 1) {
_load_TXREG();
} else if (TMR1IF) {
_systemCounter++;
TMR1IF = 0;
SignalsOnOff();
Clock > 60479900 ? Clock = 0 : Clock++;
static unsigned char dddd = 0;
if (dddd == 99) {
Clock += clock_delta;
dddd = 0;
} else {
dddd++;
}
char MinuteAgo = (Clock - Minutes > 6000);
if (MinuteAgo > 0) {
FillMinutes();
flags.RelevanceOfNextStartCell = 0;
}
}
}

unsigned long int getSystemTimePoint() {
return _systemCounter;
}

unsigned char testTimePoint(unsigned long int point, unsigned long int value) {
unsigned long int _point = getSystemTimePoint();
if (_point < point) {
_point = _point + (0xFFFFFFFF - point);
} else {
_point = _point - point;
}
return _point >= value;
}

void system_BlinkReset(unsigned char val) {
flags.IsLCDModified = 1;
GlobalBlinkCycleTime = 100;
flags.GlobalBlink = val;
}

void ProcessSystemMessageShowing() {
if (flags.LCD_Power_On && flags.UnreadSystemMessage) {
KeyCode = 0;
flags.UnreadSystemMessage = 0;
}
}

void interrupt low_priority F_l() {
asm(" clrwdt");
if (TMR0IF) {
TMR0IF = 0;

# 2771
unsigned char *digs;
digits_atributes *digsAtrib;

if (flags.UnreadSystemMessage) {
digs = digits_system_message;
digsAtrib = digitsAtrib_system_message;
} else {
digs = digits;
digsAtrib = digitsAtrib;
}

if (flags.LCD_Power_On && (GlobalBlinkCycleTime == 100 || flags.IsLCDModified)) {
for (char line = 0; line < 2; line++) {
for (int symbol = 0; symbol < 16; symbol++) {
if (GlobalBlinkCycleTime == 20 || (*(digsAtrib + 16 * line + symbol)).modifided > 0) {
unsigned char digit = *(digs + 16 * line + symbol);
lcd_send_byte((line * 0x40 + symbol) | 0b10000000);
if (!((*(digsAtrib + 16 * line + symbol)).blink == 0 || (*(digsAtrib + 16 * line + symbol)).blink == 1 && flags.GlobalBlink)) {
digit = '_';
}
SendSymbolToLCD(getLcdCodeOfChar(digit));
(*(digsAtrib + 16 * line + symbol)).modifided = 0;
}
}
}
flags.IsLCDModified = 0;
}

if (GlobalBlinkCycleTime > 0) {
GlobalBlinkCycleTime--;
} else {
flags.IsLCDModified = 1;
GlobalBlinkCycleTime = 20;
flags.GlobalBlink = !flags.GlobalBlink;

ReadTime();
}

static unsigned char ButtonPressTimeOut;

static unsigned char KeyIndex;
static unsigned char PressedKeyIndex = 0xFF;

if (ButtonPressTimeOut > 0) {
ButtonPressTimeOut--;
} else {
KeyCode = 0;
if (RB0) {
if (KeyIndex == 0x0F) {
KeyIndex = 0;
} else {
KeyIndex++;
}
unsigned char data_temp = KeyIndex;
unsigned char _KeyIndex = 0;
for (int a = 4; a > 0; a--) {
_KeyIndex *= 2;
if (data_temp % 2 == 1) {
_KeyIndex++;
}
data_temp /= 2;
}

LATB = (LATB & 0b11100000) | (KeyIndex * 2);
PressedKeyIndex = 0xFF;
if (LCD_ON_TIMEOUT > 0) {
LCD_ON_TIMEOUT--;
}
} else {
if (PressedKeyIndex == 0xFF) {
PressedKeyIndex = KeyIndex;
KeyCode = ConvKeyNum(PressedKeyIndex);
ButtonPressTimeOut = 1;
LCD_ON_TIMEOUT = 8000;
ProcessSystemMessageShowing();
}
}
}

ProcessIncommingUartData();

if(flags.ActiveCall == 0) {
flags.IncommingCall = 0;
}
}
}

void Init_USART(unsigned char SpeedNumber) {

unsigned int _value = 0;
if (SpeedNumber == 1) {
_value = 8332;
} else if (SpeedNumber == 2) {
_value = 4165;
} else if (SpeedNumber == 4) {
_value = 520;
} else if (SpeedNumber == 5) {
_value = 172;
} else {
_value = 1040;
}

TRISCbits.RC6 = 1;
TRISCbits.RC7 = 1;
BAUDCONbits.BRG16 = 1;
TXSTAbits.BRGH = 1;
SPBRG = (unsigned char) (_value % 256);
SPBRGH = (unsigned char) (_value / 256);

IPR1bits.RCIP = 1;
IPR1bits.TXIP = 1;

TXSTAbits.SYNC = 0;
RCSTAbits.SPEN = 1;
PIE1bits.RCIE = 1;
PIE1bits.TXIE = 1;

RCSTAbits.CREN = 1;

}

void main() {

flags.GSM_Connected = 0;

INTCON = 0;
INTCON2 = 0;
INTCON3 = 0;
PIR1 = 0;
PIR2 = 0;
PIE1 = 0;
PIE2 = 0;
IPR1 = 0;
IPR2 = 0;
RCON = 0;

CurrentSignals = 0;

clrInd();

clock_delta = 31;

T1CONbits.T1CKPS = 1;

RCONbits.IPEN = 1;
INTCONbits.PEIE = 1;

INTCONbits.GIEH = 1;
INTCONbits.GIEL = 1;

T2CONbits.TMR2ON = 1;

T1CONbits.RD16 = 1;
TMR1 = 51200;
T1CONbits.TMR1ON = 1;
PIE1bits.TMR1IE = 1;
IPR1bits.TMR1IP = 1;

T0CON = 0b10000001;
TMR0IE = 1;

ADCON1 = 0b00001111;
TRISA = 0b00000000;
TRISB = 0b00000001;
TRISC = 0b00100000;

Clock = ((long int) cMinutes * 60
+ (long int) cHours * 3600
+ ((long int) cWeekDay - 1) * 86400) * 100;

LATA = 0b00000000;
LATB = 0b00000000;
LATC = 0b00000000;
T2CON = 0b00100100;

flags.LockSignals = EERD(1020);

unsigned char i = 0;

# 2959
IncommingBuffer[i++] = buff_string_8;
IncommingBuffer[i++] = buff_string_9;
IncommingBuffer[i++] = buff_string_10;
IncommingBuffer[i++] = buff_string_11;

for (unsigned char i = 0; i < (3 + 1); i++) {
CleanStringArray(IncommingBuffer[i], 256, '\0');
}

GetTimeSource();
lcd_on();
main2();
}

unsigned char getNumChar(unsigned char num) {
switch (num) {
case 0: return '0';
case 1: return '1';
case 2: return '2';
case 3: return '3';
case 4: return '4';
case 5: return '5';
case 6: return '6';
case 7: return '7';
case 8: return '8';
case 9: return '9';
case 10: return 'A';
case 11: return 'B';
case 12: return 'C';
case 13: return 'D';
case 14: return 'E';
case 15: return 'F';
default: return '?';
}
}

void OutputString(unsigned char *stringData, unsigned char line, unsigned char position, unsigned char transfer_line) {
unsigned char i = 0;
unsigned char cont = 1;
while ((*(stringData + i)) != '\0' && cont == 1) {
for (; line < 2; line++) {
for (; (position < 16) && ((*(stringData + i)) != '\0');) {
setDigit(line, position, *(stringData + i));
i++;
position++;
}
position = 0;
if (!transfer_line) {
cont = 0;
break;
}
}
line = 0;
}
}

void OutputSystemMessage(unsigned char *stringData) {
for (char line = 0; line < 2; line++) {
for (char symb = 0; symb < 16; symb++) {
*(digits_system_message + line * 16 + symb) = ' ';
(*(digitsAtrib_system_message + line * 16 + symb)).blink = 0;
(*(digitsAtrib_system_message + line * 16 + symb)).modifided = 1;
}
}
unsigned int i = 0;
while (*(stringData + i) != '\0') {
for (unsigned char l = 0; l < 2; l++) {
unsigned char s = 0;
for (unsigned char position = 0; (s < 16) && (*(stringData + i) != '\0'); s++) {
(*(digitsAtrib_system_message + 16 * l + s)).modifided = 1;
*(digits_system_message + 16 * l + s) = *(stringData + i);
i++;
}
}
}
flags.UnreadSystemMessage = 1;
flags.IsLCDModified = 1;
}

void drowText(unsigned char *stringData, int startNum, int direction) {
unsigned char srcLine, destLine;
if (direction >= 0) {
srcLine = 1;
destLine = 0;
} else {
srcLine = 0;
destLine = 1;
}

for (unsigned char symbol = 0; symbol < 16; symbol++) {
*(digits + destLine * 16 + symbol) = *(digits + srcLine * 16 + symbol);
(*(digitsAtrib + destLine * 16 + symbol)).blink = (*(digitsAtrib + srcLine * 16 + symbol)).blink;
(*(digitsAtrib + destLine * 16 + symbol)).modifided = 1;
}

flags.IsLCDModified = 1;

unsigned char cutedString[17] = "                ";
for (unsigned char symbol = 0; symbol < 16; symbol++) {
unsigned char a = stringData[symbol + startNum];
if (a == '\0') {
break;
}
cutedString[symbol] = a;
}

OutputString(cutedString, (direction >= 0 ? 1 : 0), 0, 1);
}

unsigned char FindIncommingData(unsigned char *regexp, unsigned char *container, int history_index) {

unsigned char *pointer;
unsigned char *end_of_regexp = GetStringLength(regexp) - 1 + regexp;

unsigned int start_index, finish_index;
if (history_index >= 0) {
start_index = history_index;
finish_index = history_index;
} else {
start_index = 0;
finish_index = 3 - 1;
}

for (unsigned int i = start_index; i <= finish_index; i++) {
pointer = IncommingBuffer[i];
unsigned int last_s, not_found = 0;
for (unsigned int j = 0; end_of_regexp - j >= regexp && j < 256 - 1; j++) {
unsigned int s0 = *(end_of_regexp - j);
last_s = 256 - 2 - j;
unsigned int s1 = *(pointer + last_s);
if (s0 != s1 && s0 != '\x10') {
not_found = 1;
break;
}
}
if (!not_found) {
if (container != (0)) {
for (unsigned int a = 0; last_s < 256 - 1;) {
*(container + a) = *(pointer + last_s);
a++;
last_s++;
}
CleanStringArray(pointer, 256, '\0');
}
return 1;
}
}
return 0;
}

unsigned int GetStringLength(unsigned char *container) {
unsigned int i = 0;
while (*(container) != '\0') {
i++;
container++;
}
return i;
}

unsigned int _GetStringLength_interr(unsigned char *container) {
unsigned int i = 0;
while (*(container) != '\0') {
i++;
container++;
}
return i;
}

unsigned char _FindIncommingData_interrupt(unsigned char *regexp, unsigned char *container, int history_index) {

unsigned char *pointer;

unsigned char *end_of_regexp = _GetStringLength_interr(regexp) - 1 + regexp;

unsigned int start_index, finish_index;
if (history_index >= 0) {
start_index = history_index;
finish_index = history_index;
} else {
start_index = 0;
finish_index = (3 - 1);
}

for (unsigned int i = start_index; i <= finish_index; i++) {
pointer = IncommingBuffer[i];
unsigned int last_s, not_found = 0;
for (unsigned int j = 0; end_of_regexp - j >= regexp && j < 256 - 1; j++) {
unsigned int s0 = *(end_of_regexp - j);
last_s = 256 - 2 - j;
unsigned int s1 = *(pointer + last_s);
if (s0 != s1 && s0 != '\x10') {
not_found = 1;
break;
}
}
if (!not_found) {
if (container != (0)) {
for (unsigned int a = 0; last_s < 256 - 1;) {
*(container + a) = *(pointer + last_s);
a++;
last_s++;
}
_CleanStringArray_interrupt(pointer, 256, '\0');
}
return 1;
}
}
return 0;
}

void _setInputTextProps(input_text_props *_props) {
clrInd();

input_text_props props;
props.Aa = (*_props).Aa;
props.Language = (*_props).Language;

const unsigned char source_A [] = "   ";
const unsigned char source_L [] = "English    123";
unsigned char Aa [] = "   ";
unsigned char Lang [] = "       ";
while (1) {

for (unsigned char i = 0; i < 3; i++) {
Aa[i] = source_A[i + 3 * props.Aa];
}

for (unsigned char i = 0; i < 7; i++) {
Lang[i] = source_L[i + 7 * props.Language];
}

OutputString(Aa, 0, 2, 0);
OutputString(Lang, 0, 7, 0);

if (KeyCode == 35) {
KeyCode = 0;
props.Aa < 2 ? props.Aa++ : props.Aa = 0;
} else if (KeyCode == 36) {
KeyCode = 0;
props.Language < 2 ? props.Language++ : props.Language = 0;
} else if (KeyCode == 38) {
KeyCode = 0;
props.Aa > 0 ? props.Aa-- : props.Aa = 2;
} else if (KeyCode == 39) {
KeyCode = 0;
props.Language > 0 ? props.Language-- : props.Language = 2;
} else if (KeyCode == 42) {
KeyCode = 0;
(*_props).Aa = props.Aa;
(*_props).Language = props.Language;
clrInd();
break;
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
break;
}
}
}

unsigned char *InputText(unsigned char *text, input_text_props *_props, unsigned char capacity) {
input_text_props props = {AA, English, No, No};

if (_props != (0)) {
props.Aa = (*_props).Aa;
props.Language = (*_props).Language;
props.NotClearInd = (*_props).NotClearInd;
props.ReturnAfterInput = (*_props).ReturnAfterInput;
props.BlockCharSet = (*_props).BlockCharSet;
props.PhoneKeyboard = (*_props).PhoneKeyboard;
}

if (!props.NotClearInd) {
clrInd();
}

unsigned char *symbols [30];

unsigned char s_0 [] = " 0";
symbols[0] = s_0;
unsigned char s_1 [] = "1-=?+\"*#;:().,!<>~/";
symbols[1] = s_1;
unsigned char s_2 [] = "abc2";
symbols[2] = s_2;
unsigned char s_3 [] = "def3";
symbols[3] = s_3;
unsigned char s_4 [] = "ghi4";
symbols[4] = s_4;
unsigned char s_5 [] = "jkl5";
symbols[5] = s_5;
unsigned char s_6 [] = "mno6";
symbols[6] = s_6;
unsigned char s_7 [] = "pqrs7";
symbols[7] = s_7;
unsigned char s_8 [] = "tuv8";
symbols[8] = s_8;
unsigned char s_9 [] = "wxyz9";
symbols[9] = s_9;

symbols[10] = s_0;
symbols[11] = s_1;
unsigned char s_12 [] = "2";
symbols[12] = s_12;
unsigned char s_13 [] = "3";
symbols[13] = s_13;
unsigned char s_14 [] = "4";
symbols[14] = s_14;
unsigned char s_15 [] = "5";
symbols[15] = s_15;
unsigned char s_16 [] = "6";
symbols[16] = s_16;
unsigned char s_17 [] = "7";
symbols[17] = s_17;
unsigned char s_18 [] = "8";
symbols[18] = s_18;
unsigned char s_19 [] = "9";
symbols[19] = s_19;

unsigned char s_20 [] = "0+";
symbols[20] = s_20;
unsigned char s_21 [] = "1";
symbols[21] = s_21;
unsigned char s_22 [] = "2";
symbols[22] = s_22;
unsigned char s_23 [] = "3";
symbols[23] = s_23;
unsigned char s_24 [] = "4";
symbols[24] = s_24;
unsigned char s_25 [] = "5";
symbols[25] = s_25;
unsigned char s_26 [] = "6";
symbols[26] = s_26;
unsigned char s_27 [] = "7";
symbols[27] = s_27;
unsigned char s_28 [] = "8";
symbols[28] = s_28;
unsigned char s_29 [] = "9";
symbols[29] = s_29;

if (capacity == 0) {
capacity = 31;
} else {
capacity--;
}

SymbolData _input_data [33];
SymbolData * InputData [33];
for (unsigned char i = 0; i < 33; i++) {
_input_data[i].index = i;
_input_data[i].props.blink = 0;
_input_data[i].props.const_symbol = 1;
_input_data[i].number = '\0';
_input_data[i].symbol = ' ';
InputData[i] = &(_input_data[i]);
}
_input_data[32].symbol = '\0';

unsigned char active_cell = 0;
unsigned char lastKeyCode = 0;
unsigned long int time_point = 0;
unsigned char *cur_char;

if (text != (0)) {
unsigned char i = 0;
for (; *(text + i) != '\0'; i++) {
_input_data[i].symbol = *(text + i);
_input_data[i].number = 1;
active_cell = i;
}
if (active_cell < capacity) {
active_cell++;
}
}

while (1) {
if (lastKeyCode != 0 && (props.PhoneKeyboard || testTimePoint(time_point, 300))) {
lastKeyCode = 0;
if (active_cell < capacity && (*InputData[capacity]).number == '\0') {
active_cell++;
}
}

if (KeyCode >= 30 && KeyCode <= 39 || props.PhoneKeyboard && (KeyCode == 43 || KeyCode == 44)) {

if (!props.PhoneKeyboard && lastKeyCode == KeyCode) {
if (*(cur_char + 1) == '\0') {
cur_char = symbols[((KeyCode - 30) + 10 * props.Language)];
} else {
cur_char++;
}
} else {
if (KeyCode == 44) {
cur_char = symbols[1] + 6;
} else if (KeyCode == 43) {
cur_char = symbols[1] + 7;
} else {
cur_char = symbols[((KeyCode - 30) + 10 * props.Language)];
}
}

SymbolData *temp;
if (lastKeyCode != KeyCode && (*InputData[capacity]).number == '\0') {
if (active_cell < capacity && lastKeyCode != 0) {
active_cell++;
}
temp = InputData[capacity];
for (unsigned char i = capacity; i > active_cell; i--) {
InputData[i] = InputData[i - 1];
(*InputData[i]).index++;
}
InputData[active_cell] = temp;
} else {
temp = InputData[active_cell];
}

(*temp).symbol = *cur_char;
if (props.Aa == 1 && active_cell == 0 || props.Aa == 2) {
(*temp).symbol = CheckoutRegisterOfSymbol((*temp).symbol);
}
(*temp).index = active_cell;
(*temp).number = 1;

lastKeyCode = KeyCode;
KeyCode = 0;
system_BlinkReset(1);

time_point = getSystemTimePoint();

if (props.ReturnAfterInput) {
if (_props != (0)) {
(*_props).InputChar = (*temp).symbol;
}
unsigned char ret_string [33];
unsigned char i = 0;
for (; i < 33; i++) {
if ((*InputData[i]).number == '\0') {
break;
}
ret_string[i] = (*InputData[i]).symbol;
}
ret_string[i] = '\0';
if (!props.NotClearInd) {
clrInd();
}
return ret_string;
}
}
InteractiveData_BlinkOFF(InputData, 32);
(*InputData[active_cell]).props.blink = 1;

OutputInteractiveData(InputData, 32, 0);

if (KeyCode == 40) {
KeyCode = 0;
if (active_cell < capacity && (*InputData[active_cell]).number != '\0') {
active_cell++;
system_BlinkReset(0);

lastKeyCode = 0;
}
} else if (KeyCode == 41) {
KeyCode = 0;
if (active_cell > 0) {
active_cell--;
system_BlinkReset(0);

lastKeyCode = 0;
}
} else if (KeyCode == 42) {
KeyCode = 0;
(*_props).InputChar = (0);
unsigned char ret_string [33];
unsigned char i = 0;
for (; i < 33; i++) {
if ((*InputData[i]).number == '\0') {
break;
}
ret_string[i] = (*InputData[i]).symbol;
}
ret_string[i] = '\0';
if (!props.NotClearInd) {
clrInd();
}
return ret_string;
} else if (!props.PhoneKeyboard && KeyCode == 43) {
KeyCode = 0;
if (!props.NotClearInd) {
clrInd();
}
return (0);
} else if (!props.PhoneKeyboard && KeyCode == 44) {
KeyCode = 0;
if (lastKeyCode != 0) {
active_cell++;
}
if (active_cell > 0) {
SymbolData *temp = InputData[active_cell - 1];
(*temp).number = '\0';
(*temp).symbol = ' ';
(*temp).index = 31;
for (unsigned char i = active_cell - 1; i < 32; i++) {
InputData[i] = InputData[i + 1];
(*InputData[i]).index--;
}
InputData[31] = temp;
active_cell--;

lastKeyCode = 0;
}
} else if (KeyCode == 45) {
KeyCode = 0;
if(props.PhoneKeyboard){
if (!props.NotClearInd) {
clrInd();
}
return (0);
} else {
_setInputTextProps(&props);
}
}
}
}

void SendCommandToUSART(unsigned char *command, unsigned char wait) {

if (command != (0)) {
OutcommingBuffer = command;
TXSTAbits.TXEN = 1;
if (wait) {
while (OutcommingBuffer != (0));
}
}

}

void WorkingWithGSM() {
clrInd();

unsigned char myOutputString [33];
myOutputString[32] = '\0';
static unsigned char line = (3 - 1);

while (1) {

unsigned char *p = IncommingBuffer[line] + 256 - 33;
for (unsigned char i = 0; i < 32; i++) {
*(myOutputString + i) = *p++;
if (*(myOutputString + i) == '\0') {
*(myOutputString + i) = ' ';
}
}

OutputString(myOutputString, 0, 0, 1);

if (KeyCode == 33) {
KeyCode = 0;
unsigned char speed = USART_Speed_Choise();
if (speed != 0) {
Save_USART_SpeedNumber(speed);
Init_USART(speed);
}
} else if (KeyCode == 45) {
KeyCode = 0;
unsigned char *command = InputText((0), (0), 0);
SendCommandToUSART(command, 0);
} else if (KeyCode == 40) {
KeyCode = 0;
if (line > 0) {
line--;
}
} else if (KeyCode == 41) {
KeyCode = 0;
if (line < 3) {
line++;
}
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
break;
}
}
}

void testSystemTimer() {
clrInd();

unsigned char string [] = "                ";
while (1) {

unsigned long int a = getSystemTimePoint();
for (unsigned char i = 0; i < sizeof (string) - 1; i++) {
string[i] = ' ';
}
NumericToString(a, string, sizeof (string));
OutputString(string, 1, 0, 0);
if (KeyCode == 43) {
KeyCode = 0;
clrInd();
break;
}
}
}

void UserDelay(unsigned int value) {
unsigned long int timestamp = getSystemTimePoint();
while (!testTimePoint(timestamp, value));
}

unsigned char Init_GSM(unsigned char show) {

do {
flags.GSM_Connected = 0;

Init_USART(Read_USART_SpeedNumber());

if (show) {
OutputSystemMessage(" GSM-      ...");
}
SendCommandToUSART("AT", 1);
SendCommandToUSART("AT", 1);
UserDelay(20);
if (!FindIncommingData(StandardAnswer_OK, (0), (3 - 1))) {
if (show) {
UserDelay(200);
OutputSystemMessage("GSM-    ");
if (FindIncommingData("> ", (0), 3)) {
SendCommandToUSART("\x1B", 1);
}
}
break;
}

if (show) {
OutputSystemMessage(" ...");
}
unsigned long int tt = getSystemTimePoint();
unsigned char result = 0;
SendCommandToUSART("ATE0", 1);
while (!(result = FindIncommingData(StandardAnswer_OK, (0), (3 - 1))) && !testTimePoint(tt, 50));
if (!result) {
OutputSystemMessage(" ... ");
break;
}
if (show) {
OutputSystemMessage(" ... OK");
}
SendCommandToUSART("AT+CMGF=0", 1);
while (!(result = FindIncommingData(StandardAnswer_OK, (0), (3 - 1))) && !testTimePoint(tt, 50));
if (!result) {
OutputSystemMessage(" ... ");
break;
}
if (show) {
OutputSystemMessage(" ... OK  OK");
}

flags.GSM_Connected = 1;

return 1;

} while (0);

if (show) {
clrInd();
}
return 0;
}

unsigned char PowerOnGSM() {
LC5 = 0;
TRISC5 = 0;
UserDelay(200);
TRISC5 = 1;
}

void TelephoneCall(unsigned char *phone_number) {
if (phone_number == (0)) {
return;
}

volatile unsigned char command[] = "ATD              ";
unsigned char i;
for (i = 0; *(phone_number + i) != '\0'; i++) {
command[i + 3] = *(phone_number + i);
}
command[i + 3] = ';';
command[i + 4] = '\0';
SendCommandToUSART(command, 1);

}

unsigned char Select_OK_NO(unsigned char *text) {

clrInd();

while (1) {

OutputString(text, 0, 0, 1);

if (KeyCode == 42) {
KeyCode = 0;
clrInd();
return 1;
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
return 0;
}
}
}

unsigned char ShowMenu(unsigned char *menu[], unsigned char item) {

clrInd();

static unsigned char line = 0;
if (item > 0) {
item--;
}
if (item == 0) {
line = 0;
}

unsigned char result = 0;

unsigned char item_max = 0;
while (menu[item_max] != (0)) {
item_max++;
}

item_max--;

while (1) {

if (line == 0) {
OutputString(menu[item], 0, 1, 0);
if (item_max > item) {
OutputString(menu[item + 1], 1, 1, 0);
}
} else if (line == 1) {
if (item > 0) {
OutputString(menu[item - 1], 0, 1, 0);
}
OutputString(menu[item], 1, 1, 0);
}

OutputString("", line, 0, 0);

if (KeyCode == 42) {
KeyCode = 0;
result = item + 1;
break;
} else if (KeyCode == 43) {
KeyCode = 0;
result = 0;
break;
} else if (KeyCode == 40) {
KeyCode = 0;
if (item > 0) {
item--;
if (line == 1) {
line = 0;
}
}
clrInd();
} else if (KeyCode == 41) {
KeyCode = 0;
if (item < item_max) {
item++;
if (line == 0) {
line = 1;
}
}
clrInd();
}
}

clrInd();
return result;
}

void DialDTMF() {
clrInd();

input_text_props props = {AA, Numeric, Yes, Yes, Yes, Yes};
unsigned char *string = (0);
while ((string = InputText(string, &props, 32)) != (0)) {
if(props.InputChar != (0)){
unsigned char s [] = "AT+VTS=\" \"";
s[8] = props.InputChar;
SendCommandToUSART(s, 1);
}
}
clrInd();
}

void PhonebookEdit() {
clrInd();

Phone Contact;

unsigned int cell = ((8 * 48));

unsigned char read = 0;

while (1) {

if (!read) {
FillPhonebookCellFromEEPROM(&Contact, cell);
Contact.name[sizeof (Contact.name) - 1] = '\0';
Contact.phone[sizeof (Contact.phone) - 1] = '\0';
read = 1;
if (Contact.filled[0] != 1) {
Contact.name[0] = '\0';
Contact.name[sizeof (Contact.name) - 1] = '\0';
Contact.phone[0] = '\0';
Contact.phone[sizeof (Contact.phone) - 1] = '\0';
}
}

unsigned char num_cell[] = "  ";
NumericToString((cell - ((8 * 48))) / sizeof (Contact) + 1, num_cell, sizeof (num_cell));
OutputString(num_cell, 1, 14, 0);
if (Contact.filled[0] == 1) {
OutputString(Contact.name, 0, 0, 0);
OutputString(Contact.phone, 1, 0, 0);
} else {
OutputString("     <>    ", 0, 0, 0);
OutputString("             ", 1, 0, 0);
}

if (KeyCode == 45) {
KeyCode = 0;

unsigned char *menu[] = {
(0),
(0),
(0),
(0),
(0),
(0)
};

char o = 0;
if (flags.ActiveCall) {
menu[o++] = " ";
}
menu[o++] = "";
menu[o++] = " ";
menu[o++] = "";
menu[o++] = " ";

o = 1;
char result = ShowMenu(menu, 0);
if ((flags.ActiveCall ? result == o++ : 0)) {
DialDTMF();
} else if (result == o++) {
clrInd();

unsigned char *field;
input_text_props input_props = {Aa, Russian, No, No};
if ((field = InputText(
(Contact.filled[0] == 1)
?
Contact.name
:
(0),
&input_props, sizeof (Contact.name) - 1)) != (0)) {

unsigned char i;
for (i = 0; (*(field + i) != '\0'); i++) {
Contact.name[i] = *(field + i);
}
Contact.name[i] = '\0';
input_props.Language = Numeric;

if ((field = InputText(
(Contact.filled[0] == 1)
?
Contact.phone
:
(0),
&input_props, sizeof (Contact.phone) - 1)) != (0)) {

for (i = 0; (*(field + i) != '\0'); i++) {
Contact.phone[i] = *(field + i);
}
Contact.phone[i] = '\0';

Contact.filled[0] = 1;
WritePhonebookCellToEEPROM(&Contact, cell);
} else {
read = 0;
}
}
} else if (result == o++) {

input_text_props input_props = {Aa, Numeric, No, No};
unsigned char *number = InputText((0), &input_props, 13);
if (number != (0)) {
TelephoneCall(number);
flags.ActiveCall = 1;
}

} else if (result == o++) {

if (Contact.filled[0] == 1 && Select_OK_NO(" ?")) {
Phone aaa;
WritePhonebookCellToEEPROM(&aaa, cell);
read = 0;
clrInd();
}
} else if (result == o++) {
if (Select_OK_NO("  ?")) {
OutputSystemMessage("  ...");
Format_EEPROM_Memory(((8 * 48)), (((8 * 48)) + 16 * sizeof(Phone)) - 1, 0);
OutputSystemMessage("!");
}
}

} else if (KeyCode == 31) {
KeyCode = 0;
if (flags.ActiveCall) {
SendCommandToUSART("ATA", 0);
} else if (Contact.filled[0] == 1 && Select_OK_NO(" ?")) {
if (Contact.filled[0] == 1) {
TelephoneCall(Contact.phone);
flags.ActiveCall = 1;
}
}
} else if (KeyCode == 33) {
KeyCode = 0;
SendCommandToUSART("ATH0", 0);
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;
} else if (KeyCode == 40) {
KeyCode = 0;
if (cell < ((((8 * 48)) + 16 * sizeof(Phone)) - sizeof(Phone))) {
cell = cell + sizeof (Contact);
} else {
cell = ((8 * 48));
}
read = 0;
clrInd();
} else if (KeyCode == 41) {
KeyCode = 0;
if (cell > ((8 * 48))) {
cell = cell - sizeof (Contact);
} else {
cell = ((((8 * 48)) + 16 * sizeof(Phone)) - sizeof(Phone));
}
read = 0;
clrInd();
} else if (KeyCode == 43) {
KeyCode = 0;
clrInd();
return;
} else if (KeyCode == 30) {
KeyCode = 0;
cell = ((8 * 48));
read = 0;
clrInd();
}
}
}

unsigned char Read_USART_SpeedNumber() {
unsigned char v = EERD(1021);
if (v > 3) {
v = 1;
}
return v;
}

void Save_USART_SpeedNumber(unsigned char speed) {
if (speed == 0 || speed == 0xFF) {
speed == 3;
}
EEWR(1021, speed);
}

unsigned char USART_Speed_Choise() {
unsigned char *menu[] = {
" 1200",
" 2400",
" 9600",


(0)
};
return ShowMenu(menu, Read_USART_SpeedNumber());
}

void Settings() {

char item = 0;
unsigned char *menu[] = {
". ",
" USART",
". GSM",
" GSM",
" GSM",
". GSM",
" GSM-",
". ",
(0)
};

do {

unsigned char num = 1;

item = ShowMenu(menu, item);

if (item == num++) {
TimeEdit();
} else if (item == num++) {
unsigned char speed = USART_Speed_Choise();
if (speed != 0) {
Save_USART_SpeedNumber(speed);
}
} else if (item == num++) {

unsigned char *menu_GSM_on_off[] = {
"",
"",
(0)
};
unsigned char GSM_Condition = EERD(1023);
if (GSM_Condition != 1) {
GSM_Condition = 0;
}
unsigned char GSM_On_Off = ShowMenu(menu_GSM_on_off, GSM_Condition + 1);
if (GSM_On_Off != 0) {
if (GSM_On_Off == 1) {
flags.GSM_Connected = 0;
}
EEWR(1023, GSM_On_Off - 1);
}
} else if (item == num++) {
PowerOnGSM();
OutputSystemMessage("");
} else if (item == num++) {
SendCommandToUSART("AT+CPOWD=1", 1);
} else if (item == num++) {
Init_GSM(1);
} else if (item == num++) {
if (flags.GSM_Connected) {
unsigned long int tt = getSystemTimePoint();
CleanStringArray(IncommingBuffer[(3 - 1)], 256, '\0');
SendCommandToUSART("AT+CSQ", 1);
unsigned char result = 0;
while (!(result = FindIncommingData(StandardAnswer_OK, (0), (3 - 1))) && !testTimePoint(tt, 20));
if (result) {
unsigned char myOutputString [33];
myOutputString[32] = '\0';

unsigned char *p = IncommingBuffer[(3 - 1) - 1] + 256 - 33;
for (unsigned char i = 0; i < 32; i++) {
*(myOutputString + i) = *p++;
if (*(myOutputString + i) == '\0') {
*(myOutputString + i) = ' ';
}
}

OutputSystemMessage(myOutputString);
} else {
OutputSystemMessage(" ");
}
} else {
OutputSystemMessage("  ");
}
} else if (item == num++) {
Format_EEPROM_Memory(0, 1023, 1);
}
} while (item > 0);
}

unsigned char *GetSystemInfo() {

unsigned char info [73];
CleanStringArray(info, sizeof (info), '\0');
strcat(info, ". .:\n");

unsigned char d;
if (!flags.LockSignals) {
strcat(info, ": ");
unsigned char s_auto [] = "   \n";
d = 0b00001000;
for (unsigned char i = 3; i > 0; i--) {
d = d >> 1;
if ((SignalsForInd & d) != 0) {
s_auto[i - 1] = getNumChar(i);
} else {
s_auto[i - 1] = '-';
}
}
strcat(info, s_auto);
}

strcat(info, ": ");
unsigned char s_hand [] = "   \n";
d = 0b00001000;
for (unsigned char i = 3; i > 0; i--) {
d = d >> 1;
if ((CurrentSignals & d) != 0) {
s_hand[i - 1] = getNumChar(i);
} else {
s_hand[i - 1] = '-';
}
}
strcat(info, s_hand);

if (flags.LockSignals) {
strcat(info, " .\n");
}

# 4083
if (!flags.LockSignals) {

long int cTime = Clock;
unsigned int NextCell = FindNextTimeStart(&cTime);

if (NextCell == (8 * 48)) {
cTime = 0;
NextCell = FindNextTimeStart(&cTime);
}
if (NextCell == (8 * 48)) {
strcat(info, "  .\n");
} else {
strcat(info, ". .:\n");

unsigned char DataArray [] = " 11:00-11:59 123";
CleanStringArray(DataArray, sizeof (DataArray), '\0');

unsigned long int Data = 0;
unsigned char CellsData [8];
ReadDataOfCell(&CellsData, &Data, NextCell);

unsigned int TimeStart;
unsigned int TimeStop;
unsigned char Days;
unsigned char Signals;
ParseDataRecord(Data, &TimeStart, &TimeStop, &Days, &Signals);

unsigned int Time;
unsigned char Day;
ParseTime(cTime, &Time, &Day);

unsigned char m_1 [] = "00";
NumericToString(Time % 60, m_1, 2);

Time /= 60;

unsigned char h_1 [] = "00";
NumericToString(Time, h_1, 2);

unsigned char m_2 [] = "00";
NumericToString(TimeStop % 60, m_2, 2);

TimeStop /= 60;

unsigned char h_2 [] = "00";
NumericToString(TimeStop, h_2, 2);
strcat(DataArray, GetDayOfWeek(Day));
strcat(DataArray, " ");
strcat(DataArray, h_1);
strcat(DataArray, ":");
strcat(DataArray, m_1);
strcat(DataArray, "-");
strcat(DataArray, h_2);
strcat(DataArray, ":");
strcat(DataArray, m_2);
strcat(DataArray, " ");

unsigned char sss [] = "   \n";
d = 0b00001000;
for (unsigned char i = 3; i > 0; i--) {
d = d >> 1;
if ((Signals & d) != 0) {
sss[i - 1] = getNumChar(i);
} else {
sss[i - 1] = '-';
}
}
strcat(DataArray, sss);
strcat(info, DataArray);
}
}

return info;
}

void main2() {

flags.UsartExchangeEnabled = 1;

flags.UseGSM = EERD(1023);

if (flags.UseGSM == 1) {
for (unsigned char i = 0; i < 5; i++) {
if (Init_GSM(1)) {
flags.SendTimeRequest = 1;
break;
} else {
if (KeyCode == 43) {
KeyCode = 0;
break;
}
PowerOnGSM();
UserDelay(50);
}
}
}

NearTimeStart = Clock;
AdressOfNextStartCell = FindNextTimeStart(&NearTimeStart);

unsigned long int t1 = getSystemTimePoint();

while (1) {

if(flags.UseGSM && testTimePoint(t1, 3000)){
t1 = getSystemTimePoint();
CleanStringArray(IncommingBuffer[(3 - 1)], 256, '\0');
SendCommandToUSART("AT", 1);
unsigned long int t2 = getSystemTimePoint();
while (!FindIncommingData(StandardAnswer_OK, (0), (3 - 1)) && !testTimePoint(t2, 50));
if(testTimePoint(t2, 50)){
flags.ActiveCall = 0;
flags.RemoteControlIsEnabled = 0;
flags.StatusIsRequested = 0;
CleanStringArray(active_phone, sizeof (active_phone), '\0');
PowerOnGSM();
Init_GSM(0);
}else{
flags.GSM_Connected = 1;
}
}

if (flags.StatusIsRequested) {
flags.StatusIsRequested = 0;
SendSMS(active_phone, GetSystemInfo());
CleanStringArray(active_phone, sizeof (active_phone), '\0');
}

if (flags.LCD_Power_On == 1 && LCD_ON_TIMEOUT == 0) {
lcd_off();
} else if (flags.LCD_Power_On == 0 && KeyCode != 0) {
KeyCode = 0;
lcd_on();
}

if (flags.LCD_Power_On == 0) {
continue;
}

TimeToInd();

if (KeyCode == 45 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
char item = 0;
unsigned char *menu[] = {


"",
(0)
};
do {

item = ShowMenu(menu, item);

# 4242
if (item == 1) {
Settings();
}
} while (item > 0);
clrInd();
} else if (KeyCode == 40) {
KeyCode = 0;
Scheduler((8 * 48));
} else if (KeyCode == 41) {
KeyCode = 0;
PhonebookEdit();
} else if (KeyCode == 44) {
KeyCode = 0;
if (flags.LCD_Power_On) {
flags.LCD_Light_On = !flags.LCD_Light_On;
}
} else if (KeyCode == 30) {
KeyCode = 0;
flags.LockSignals = 1;
CurrentSignals = 0;
EEWR(1020, flags.LockSignals);
flags.SignalsAreChanged = 1;
} else if (KeyCode == 37 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
CurrentSignals = CurrentSignals^0b00000001;
flags.SignalsAreChanged = 1;
} else if (KeyCode == 38 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
CurrentSignals = CurrentSignals^0b00000010;
flags.SignalsAreChanged = 1;
} else if (KeyCode == 39 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
CurrentSignals = CurrentSignals^0b00000100;
flags.SignalsAreChanged = 1;
} else if (KeyCode == 34 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
CurrentSignals = 0;
flags.SignalsAreChanged = 1;
} else if (KeyCode == 35 && !flags.DetailModeOfViewSheduler) {
KeyCode = 0;
flags.LockSignals = 0;
EEWR(1020, flags.LockSignals);
flags.SignalsAreChanged = 1;
} else if (KeyCode == 31) {
KeyCode = 0;
lcd_off();
} else if (KeyCode == 33) {
KeyCode = 0;
WorkingWithGSM();
} else if (KeyCode == 42) {
KeyCode = 0;
current_showing = csTemperature;

} else if (KeyCode == 43 || (KeyCode == 36 && (!flags.LockSignals || flags.DetailModeOfViewSheduler))) {
if (KeyCode == 43) {
NearTimeStart = Clock;
if (flags.DetailModeOfViewSheduler) {
flags.DetailModeOfViewSheduler = 0;
clrInd();
}
}
KeyCode = 0;
FillMinutes();
AdressOfNextStartCell = FindNextTimeStart(&NearTimeStart);
}
}
}

unsigned char BCD_to_DEC(unsigned char BCD) {
return ((BCD & 0b11110000) >> 4) * 10 + (BCD & 0b00001111);
}

unsigned char DEC_to_BCD(unsigned char DEC) {
if (DEC > 99) {
DEC = 99;
}
return ((DEC / 10) << 4) +DEC % 10;
}

void ReadTime() {

if (flags.TimeSource == NON) {
return;
}

static unsigned long int lastTimeStamp = 0;

if (testTimePoint(lastTimeStamp, 4000) || lastTimeStamp == 0 || flags.SendTimeRequest) {
lastTimeStamp = getSystemTimePoint();
flags.SendTimeRequest = 0;
} else {
return;
}

if (flags.TimeSource == RTC) {
return;

unsigned char Seconds = 0x00;

I2CInit();
I2CStart();
I2CSend(0xD0);
I2CSend(0x00);
I2CRestart();
I2CSend(0xD1);


unsigned char I = I2CRead();

if ((I & 0b10000000) == 0) {
I2CAck();
Seconds = BCD_to_DEC(I);
cMinutes = BCD_to_DEC(I2CRead());
I2CAck();
cHours = BCD_to_DEC(I2CRead());
I2CAck();
cWeekDay = BCD_to_DEC(I2CRead());
I2CAck();
cDays = BCD_to_DEC(I2CRead());
I2CAck();
cMonths = BCD_to_DEC(I2CRead());
I2CAck();
cYears = BCD_to_DEC(I2CRead());
} else {
I2CNak();
I2CStop();
cDays = EERD(1017);
cMonths = EERD(1018);
cYears = EERD(1019);

return;
}
I2CNak();

I2CStop();

Clock = ((long int) Seconds
+ (long int) cMinutes * 60
+ (long int) cHours * 3600
+ ((long int) cWeekDay - 1) * 86400) * 100;
} else if (flags.TimeSource == GSM && flags.GSM_Connected && flags.UsartExchangeEnabled) {
SendCommandToUSART("AT+CCLK?", 0);
}
}

void WriteTime(unsigned long int lClock, unsigned char days, unsigned char months, unsigned char years) {

if (flags.TimeSource == RTC) {
return;

volatile unsigned char INTCON_BUP = INTCON;
INTCONbits.GIEH = 0;
INTCONbits.GIEL = 0;


unsigned char week_day;
unsigned char hours;
unsigned char minutes;

lClock /= 6000;
minutes = DEC_to_BCD(lClock % 60);
lClock /= 60;
hours = DEC_to_BCD(lClock % 24);
lClock /= 24;
week_day = DEC_to_BCD(lClock + 1);

I2CInit();
I2CStart();
I2CSend(0xD0);
I2CSend(0x00);

I2CSend(0x00);
I2CSend(minutes);
I2CSend(hours);
I2CSend(week_day);
I2CSend(DEC_to_BCD(days));
I2CSend(DEC_to_BCD(months));
I2CSend(DEC_to_BCD(years));
I2CSend(0b00010000);

I2CStop();

INTCON = INTCON_BUP;
} else if (flags.TimeSource == GSM && flags.GSM_Connected && flags.UsartExchangeEnabled) {
unsigned char comand [] = "AT+CCLK=\"yy/mm/dd,hh:mm:00+03\"";
long int temp = Clock / 6000;
comand[22] = getNumChar(temp % 10);
temp /= 10;
comand[21] = getNumChar(temp % 6);
temp /= 6;
temp = temp % 24;
comand[19] = getNumChar(temp % 10);
temp /= 10;
comand[18] = getNumChar(temp);

comand[16] = getNumChar(cDays % 10);
comand[15] = getNumChar(cDays / 10);
comand[13] = getNumChar(cMonths % 10);
comand[12] = getNumChar(cMonths / 10);
comand[10] = getNumChar(cYears % 10);
comand[9] = getNumChar(cYears / 10);

SendCommandToUSART(comand, 1);
}
}

void I2CInit(void) {
TRISCbits.TRISC3 = 1;
TRISCbits.TRISC4 = 1;
SSPSTAT |= 0b10000000;
SSPADD = 0x18;
SSPCON1 = 0b00101000;
}

void I2CStart() {
SSPCON2bits.SEN = 1;
while (SSPCON2bits.SEN);

}

void I2CStop() {
SSPCON2bits.PEN = 1;
while (SSPCON2bits.PEN);

}

void I2CRestart() {
SSPCON2bits.RSEN = 1;
while (SSPCON2bits.RSEN);
}

void I2CAck() {
SSPCON2bits.ACKDT = 0;
SSPCON2bits.ACKEN = 1;
while (SSPCON2bits.ACKEN);
}

void I2CNak() {
SSPCON2bits.ACKDT = 1;
SSPCON2bits.ACKEN = 1;
while (SSPCON2bits.ACKEN);
}

void I2CSend(unsigned char dat) {
SSPBUF = dat;
while (SSPSTATbits.BF);
while ((SSPCON2 & 0b00011111) || (SSPSTAT & 0b00000100));
}

unsigned char I2CRead(void) {
unsigned char temp;

SSPCON2bits.RCEN = 1;
while (!SSPSTATbits.BF);
temp = SSPBUF;
while ((SSPCON2 & 0b00011111) || (SSPSTAT & 0b00000100));
return temp;
}

unsigned char *EncodePhoneNumberToPDU(unsigned char *phone_number) {
if (*phone_number == '+') {
phone_number++;
}
unsigned char number_legth = strlen(phone_number);

unsigned char encoded [15];
strcpy(encoded, phone_number);
if (number_legth % 2 != 0) {
strcat(encoded, "F");
}

unsigned char temp;
for (unsigned char i = 0; encoded[i] != '\0'; i += 2) {
temp = encoded[i];
encoded[i] = encoded[i + 1];
encoded[i + 1] = temp;
}
return encoded;
}

void cp1251_to_unicode(unsigned char *dest, unsigned char *src, unsigned char *eof) {
unsigned int a = 0;
while (dest < eof && *src != '\0') {
a = GetUnicodeSymbol(*(src));
unsigned char t [] = "0000";
NumericToHEXString(a, t, 4);
strcat(dest, t);
dest += 4;
src++;
}
}

void SendSMS(unsigned char *PhoneNumber, unsigned char *Text) {

if (flags.GSM_Connected != 1) {
return;
}

CleanStringArray(SMS, sizeof (SMS), '\0');

strcat(SMS, "00");

unsigned int sc_len = strlen(SMS);

unsigned char *pn = PhoneNumber;
if (*pn == '+') {
pn++;
}

strcat(SMS, "0100");
unsigned char tempString [] = "00";
NumericToHEXString(strlen(pn), tempString, 2);
strcat(SMS, tempString);
strcat(SMS, "91");
unsigned char *myNumber = EncodePhoneNumberToPDU(PhoneNumber);
strcat(SMS, myNumber);
strcat(SMS, "00");
strcat(SMS, "18");

unsigned int l = strlen(Text) * 2;
unsigned char e [] = "00";
NumericToHEXString(l, e, 2);
strcat(SMS, e);

cp1251_to_unicode(&(SMS[0]) + strlen(SMS), Text, &(SMS[0]) + sizeof (SMS) - 1);
sc_len = (strlen(SMS) - sc_len) / 2;
strcat(SMS, "\x1A");
unsigned char y [] = "\0\0\0";
NumericToString(sc_len, y, (sc_len > 99 ? 4 : (sc_len > 9 ? 3 : 2)));
unsigned char command [] = "AT+CMGS=\0\0\0";
strcat(command, y);

flags.UsartExchangeEnabled = 0;
unsigned long int tt = getSystemTimePoint();
SendCommandToUSART(command, 1);
while (!FindIncommingData("> ", (0), 3) && !testTimePoint(tt, 1500));
if (FindIncommingData("> ", (0), 3)) {
SendCommandToUSART(SMS, 1);
} else {
OutputSystemMessage("   ");
}
flags.UsartExchangeEnabled = 1;
}
